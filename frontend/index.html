<!DOCTYPE html>
<html>
  <!--
    SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
    SPDX-License-Identifier: MIT
  -->

  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <h3> TURN 服务器测试 </h3>
    <button id="testTurnBtn">测试 TURN 服务器连通性</button>
    <div id="turnTestResult"></div>
    <br />

    <h3> 媒体源选择 </h3>
    <button id="cameraBtn">使用摄像头</button>
    <button id="screenBtn">屏幕共享</button>
    <span id="currentSource">当前：未选择</span>
    <br /><br />

    <h3> 本地视频 </h3>
    <video id="localVideo" width="320" height="240" autoplay muted></video> <br />

    <h3> 远程视频 </h3>
    <div id="remoteVideos"></div> <br />

    <h3> 日志 </h3>
    <div id="logs"></div>
  </body>

  <script>
    let peer_connection;
    let ws;
    let currentStream;

    // 测试 TURN 服务器连通性
    async function testTurnServer() {
      const resultDiv = document.getElementById('turnTestResult');
      resultDiv.innerHTML = '<p>正在测试 TURN 服务器连通性...</p>';
      
      try {
        const testPC = new RTCPeerConnection({
          iceServers: [
            {
              urls: 'turn:117.72.204.201:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            },
            {
              urls: 'turn:117.72.204.201:3478?transport=udp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ],
          iceTransportPolicy: 'relay' // 强制只使用 TURN
        });

        let turnCandidateFound = false;
        
        testPC.onicecandidate = (event) => {
          if (event.candidate && event.candidate.type === 'relay') {
            turnCandidateFound = true;
            resultDiv.innerHTML = '<p style="color: green;">✓ TURN 服务器连接成功！</p>';
            console.log('TURN candidate found:', event.candidate);
          }
        };

        // 创建数据通道触发 ICE 收集
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // 等待 ICE 收集完成
        setTimeout(() => {
          if (!turnCandidateFound) {
            resultDiv.innerHTML = '<p style="color: red;">✗ TURN 服务器连接失败！请检查：<br/>1. 服务器地址是否正确<br/>2. 用户名密码是否正确<br/>3. 端口是否被防火墙阻塞<br/>4. TURN 服务器是否正常运行</p>';
          }
          testPC.close();
        }, 5000);

      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">测试失败: ${error.message}</p>`;
        console.error('TURN test error:', error);
      }
    }

    // 获取摄像头流
    async function getCameraStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = '当前：摄像头';
        return stream;
      } catch (error) {
        console.error('获取摄像头失败:', error);
        window.alert('获取摄像头失败: ' + error.message);
        throw error;
      }
    }

    // 获取屏幕共享流
    async function getScreenStream() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = '当前：屏幕共享';
        return stream;
      } catch (error) {
        console.error('获取屏幕共享失败:', error);
        window.alert('获取屏幕共享失败: ' + error.message);
        throw error;
      }
    }

    // 替换媒体流
    async function replaceMediaStream(getStreamFunction) {
      try {
        const newStream = await getStreamFunction();
        
        // 如果已有连接，替换轨道
        if (peer_connection && currentStream) {
          // 移除旧的轨道
          const senders = peer_connection.getSenders();
          for (const sender of senders) {
            if (sender.track) {
              peer_connection.removeTrack(sender);
            }
          }
          
          // 添加新的轨道
          newStream.getTracks().forEach(track => {
            peer_connection.addTrack(track, newStream);
          });
        }

        // 停止旧流
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        // 更新本地视频显示
        document.getElementById('localVideo').srcObject = newStream;
        currentStream = newStream;

        // 监听屏幕共享结束事件
        if (getStreamFunction === getScreenStream) {
          newStream.getVideoTracks()[0].addEventListener('ended', () => {
            console.log('屏幕共享已结束，切换回摄像头');
            replaceMediaStream(getCameraStream);
          });
        }

      } catch (error) {
        console.error('替换媒体流失败:', error);
      }
    }

    // 初始化WebRTC连接
    function initializeWebRTC(stream) {
      currentStream = stream;
      
      // 2. 创建 WebRTC 的 RTCPeerConnection 实例 
      // RTCPeerConnection 是 WebRTC 的核心接口，用于建立点对点连接
      // 负责处理音视频流的传输、ICE 协商等
      peer_connection = new RTCPeerConnection(
        {
          iceServers: [
            // **你的 STUN 服务器配置**
            {
                urls: 'stun:117.72.204.201:3478'
            },
            // **你的 TURN 服务器配置 - TCP**
            {
                urls: 'turn:117.72.204.201:3478?transport=tcp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **你的 TURN 服务器配置 - UDP**
            {
                urls: 'turn:117.72.204.201:3478?transport=udp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **Google 的公共 STUN 服务器作为备用**
            {
                urls: 'stun:stun.l.google.com:19302'
            },
            // **Cloudflare STUN 服务器作为备用**
            {
                urls: 'stun:stun.cloudflare.com:3478'
            }
          ],
          // 强制使用 TURN 服务器（用于测试）
          iceTransportPolicy: 'all' // 可以改为 'relay' 强制只使用 TURN
        }
      )

      // 3. 监听远端 track 事件（接收到远端媒体流时触发）
      peer_connection.ontrack = function (event) {
        // 只处理视频轨道，忽略音频
        console.log('ontrack', event)
        if (event.track.kind === 'audio') {
          return
        }

        // 创建 video 元素用于播放远端视频
        let el = document.createElement(event.track.kind)
        el.srcObject = event.streams[0]
        el.autoplay = true
        el.controls = true
        document.getElementById('remoteVideos').appendChild(el)

        // 远端 track 静音时尝试播放（兼容部分浏览器策略）
        event.track.onmute = function(event) {
          el.play()
        }

        // 远端流移除 track 时，移除 video 元素
        event.streams[0].onremovetrack = ({track}) => {
          if (el.parentNode) {
            el.parentNode.removeChild(el)
          }
        }
      }

      // 4. 显示本地视频流
      document.getElementById('localVideo').srcObject = stream
      // 5. 将本地音视频轨道添加到 RTCPeerConnection
      stream.getTracks().forEach(track => peer_connection.addTrack(track, stream))

      // 6. 建立 WebSocket 连接到后端信令服务器
      ws = new WebSocket("wss://meteor.matrix-net.tech/websocket")
      //ws = new WebSocket("ws://117.72.204.201:8080/websocket")

      // 7. 监听 ICE candidate 事件，将本地 candidate 发送给后端
      peer_connection.onicecandidate = e => {
        if (!e.candidate) {
          console.log('ICE gathering complete')
          return
        }
        // 记录 ICE candidate 类型以便调试
        console.log('ICE Candidate:', {
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidate: e.candidate.candidate
        })
        // 发送 candidate 消息，data 字段为字符串化的 candidate 对象
        ws.send(JSON.stringify({event: 'candidate', data: JSON.stringify(e.candidate)}))
      }

      // 监听 ICE 连接状态变化
      peer_connection.oniceconnectionstatechange = () => {
        console.log('ICE Connection State:', peer_connection.iceConnectionState)
        const logDiv = document.getElementById('logs')
        logDiv.innerHTML += `<p>ICE 连接状态: ${peer_connection.iceConnectionState}</p>`
        
        if (peer_connection.iceConnectionState === 'failed') {
          logDiv.innerHTML += '<p style="color: red;">ICE 连接失败！可能的原因：1. TURN服务器不可用 2. 网络防火墙阻塞 3. NAT类型不兼容</p>'
        } else if (peer_connection.iceConnectionState === 'connected') {
          logDiv.innerHTML += '<p style="color: green;">ICE 连接成功！</p>'
        }
      }

      // 监听连接状态变化
      peer_connection.onconnectionstatechange = () => {
        console.log('Connection State:', peer_connection.connectionState)
        const logDiv = document.getElementById('logs')
        logDiv.innerHTML += `<p>连接状态: ${peer_connection.connectionState}</p>`
      }

      // 8. WebSocket 关闭时弹窗提示
      ws.onclose = function(evt) {
        window.alert("Websocket has closed")
      }

      // 9. WebSocket 收到消息时的处理逻辑
      ws.onmessage = function(evt) {
        // 解析收到的 JSON 消息
        let msg = JSON.parse(evt.data)
        // 输出日志到页面
        console.log('ws message', msg)
        if (!msg) {
          return console.log('failed to parse msg')
        }

        // 根据 event 字段类型分支处理
        switch (msg.event) {
          case 'paired':
            // 收到 'paired' 事件，根据 data 判断是否为发起方
            // data 为 "true" 表示是发起方，需要创建并发送 offer
            if (msg.data === "true") {
              console.log("I am the initiator, creating offer...")
              peer_connection.createOffer().then(offer => {
                peer_connection.setLocalDescription(offer)
                ws.send(JSON.stringify({event: 'offer', data: JSON.stringify(offer)}))
              })
            } else {
              console.log("I am the receiver, waiting for offer...")
            }
            return

          case 'offer':
            // 收到服务器发来的 offer，解析后设置为远端描述
            let offer = JSON.parse(msg.data)
            if (!offer) {
              return console.log('failed to parse offer')
            }
            console.log("Received offer, creating answer...")
            peer_connection.setRemoteDescription(offer)
            // 创建 answer 并发送回服务器
            peer_connection.createAnswer().then(answer => {
              peer_connection.setLocalDescription(answer)
              ws.send(JSON.stringify({event: 'answer', data: JSON.stringify(answer)}))
            })
            return
          
          case 'answer':
            // 收到服务器转发的 answer，解析后设置为远端描述
            let answer = JSON.parse(msg.data)
            if (!answer) {
              return console.log('failed to parse answer')
            }
            peer_connection.setRemoteDescription(answer)
            return

          case 'candidate':
            // 收到服务器转发的 candidate，解析后加入 RTCPeerConnection
            let candidate = JSON.parse(msg.data)
            console.log('收到远端 ICE Candidate:', {
              type: candidate.type,
              protocol: candidate.protocol,
              address: candidate.address,
              port: candidate.port
            })
            // 如果 candidate 解析失败，输出日志并返回
            if (!candidate) {
              return console.log('failed to parse candidate')
            }
            peer_connection.addIceCandidate(candidate).catch(err => {
              console.error('添加 ICE candidate 失败:', err)
            })
        }
      }

      // 10. WebSocket 发生错误时输出日志
      ws.onerror = function(evt) {
        console.log("ERROR: " + evt.data)
      }
    }

    // 页面加载完成后设置事件监听器
    document.addEventListener('DOMContentLoaded', function() {
      // TURN 服务器测试按钮
      document.getElementById('testTurnBtn').addEventListener('click', testTurnServer);

      // 摄像头按钮事件
      document.getElementById('cameraBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getCameraStream);
        } else {
          getCameraStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // 屏幕共享按钮事件
      document.getElementById('screenBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getScreenStream);
        } else {
          getScreenStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // 默认使用摄像头
      getCameraStream().then(stream => {
        initializeWebRTC(stream);
      }).catch(console.error);
    });
  </script>
</html>
