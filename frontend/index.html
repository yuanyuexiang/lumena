<!DOCTYPE html>
<html>
  <!--
    SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
    SPDX-License-Identifier: MIT
  -->

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumena è§†é¢‘é€šè¯</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: #333;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 30px;
        backdrop-filter: blur(10px);
      }

      h1 {
        text-align: center;
        color: #4a5568;
        margin-bottom: 30px;
        font-size: 2.5em;
        font-weight: 300;
      }

      .section {
        background: white;
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        border: 1px solid #e2e8f0;
      }

      .section h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3em;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .section h3::before {
        content: '';
        width: 4px;
        height: 20px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        border-radius: 2px;
      }

      .btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        margin: 5px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.danger {
        background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      }

      .btn.danger:hover {
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
      }

      .btn.success {
        background: linear-gradient(135deg, #51cf66, #40c057);
        box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
      }

      .btn.success:hover {
        box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
      }

      .video-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .video-box {
        background: #f8f9fa;
        border-radius: 15px;
        padding: 15px;
        text-align: center;
        border: 2px solid #e9ecef;
      }

      video {
        width: 100%;
        max-width: 400px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .status-box {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 1px solid #dee2e6;
        border-radius: 15px;
        padding: 20px;
        margin: 15px 0;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding: 8px 0;
        border-bottom: 1px solid #e9ecef;
      }

      .status-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }

      .status-label {
        font-weight: 600;
        color: #495057;
      }

      .status-value {
        color: #6c757d;
        font-family: 'Courier New', monospace;
        background: rgba(255, 255, 255, 0.7);
        padding: 4px 8px;
        border-radius: 5px;
      }

      .logs {
        background: #1a1a1a;
        color: #00ff00;
        padding: 20px;
        border-radius: 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        margin-top: 15px;
      }

      .logs p {
        margin-bottom: 5px;
        line-height: 1.4;
      }

      .result-box {
        margin-top: 15px;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
      }

      .current-source {
        background: rgba(102, 126, 234, 0.1);
        color: #667eea;
        padding: 5px 12px;
        border-radius: 15px;
        font-weight: 500;
        margin-left: 10px;
      }

      .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
      }

      .icon {
        width: 20px;
        height: 20px;
        margin-right: 8px;
      }

      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
      }

      @media (max-width: 768px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }
        
        .container {
          padding: 15px;
          margin: 10px;
        }
        
        h1 {
          font-size: 2em;
        }
      }

      /* åŠ¨ç”»æ•ˆæœ */
      .section {
        animation: slideInUp 0.6s ease;
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */
      .connection-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 2s infinite;
      }

      .connection-indicator.connected {
        background-color: #51cf66;
      }

      .connection-indicator.disconnected {
        background-color: #ff6b6b;
      }

      .connection-indicator.connecting {
        background-color: #ffd43b;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ğŸ¥ Lumena è§†é¢‘é€šè¯</h1>
      
      <div class="grid-2">
        <div>
          <!-- ç½‘ç»œè¯Šæ–­åŒºåŸŸ -->
          <div class="section">
            <h3>ğŸ”§ ç½‘ç»œè¯Šæ–­</h3>
            <div class="button-group">
              <button id="testTurnBtn" class="btn">æµ‹è¯• TURN æœåŠ¡å™¨</button>
              <button id="diagnosisBtn" class="btn">ç½‘ç»œè¯Šæ–­</button>
              <button id="forceRelayBtn" class="btn">å¼ºåˆ¶ TURN æ¨¡å¼</button>
            </div>
            <div id="turnTestResult" class="result-box"></div>
            <div id="diagnosisResult" class="result-box"></div>
          </div>

          <!-- åª’ä½“æºé€‰æ‹© -->
          <div class="section">
            <h3>ğŸ“¹ åª’ä½“æºé€‰æ‹©</h3>
            <div class="button-group">
              <button id="cameraBtn" class="btn success">ğŸ“· ä½¿ç”¨æ‘„åƒå¤´</button>
              <button id="screenBtn" class="btn">ğŸ–¥ï¸ å±å¹•å…±äº«</button>
            </div>
            <span id="currentSource" class="current-source">å½“å‰ï¼šæœªé€‰æ‹©</span>
          </div>

          <!-- è¿æ¥çŠ¶æ€ -->
          <div class="section">
            <h3>ğŸ“¡ è¿æ¥çŠ¶æ€</h3>
            <div class="status-box">
              <div class="status-item">
                <span class="status-label">è¿æ¥æ–¹å¼:</span>
                <span class="status-value">
                  <span class="connection-indicator disconnected"></span>
                  <span id="connectionType">æœªè¿æ¥</span>
                </span>
              </div>
              <div class="status-item">
                <span class="status-label">æœ¬åœ°å€™é€‰:</span>
                <span class="status-value" id="localCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">è¿œç¨‹å€™é€‰:</span>
                <span class="status-value" id="remoteCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">ç½‘ç»œå»¶è¿Ÿ:</span>
                <span class="status-value" id="networkDelay">-</span>
              </div>
            </div>
          </div>
        </div>

        <div>
          <!-- è§†é¢‘åŒºåŸŸ -->
          <div class="section">
            <h3>ğŸ¬ è§†é¢‘é¢„è§ˆ</h3>
            <div class="video-container">
              <div class="video-box">
                <h4>æœ¬åœ°è§†é¢‘</h4>
                <video id="localVideo" width="320" height="240" autoplay muted></video>
              </div>
              <div class="video-box">
                <h4>è¿œç¨‹è§†é¢‘</h4>
                <div id="remoteVideos"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- æ—¥å¿—åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logs" class="logs"></div>
      </div>
    </div>
  </body>

  <script>
    let peer_connection;
    let ws;
    let currentStream;
    let forceRelay = false; // æ˜¯å¦å¼ºåˆ¶ä½¿ç”¨ TURN
    let connectionStatsInterval; // è¿æ¥çŠ¶æ€æ£€æµ‹å®šæ—¶å™¨

    // æ£€æµ‹è¿æ¥ç±»å‹å’ŒçŠ¶æ€
    async function checkConnectionType() {
      if (!peer_connection) return;

      try {
        const stats = await peer_connection.getStats();
        let localCandidate = null;
        let remoteCandidate = null;
        let connectionType = 'æœªçŸ¥';
        let rtt = null;

        stats.forEach(report => {
          // è·å–æœ¬åœ°å€™é€‰ä¿¡æ¯
          if (report.type === 'local-candidate') {
            localCandidate = report;
          }
          // è·å–è¿œç¨‹å€™é€‰ä¿¡æ¯
          if (report.type === 'remote-candidate') {
            remoteCandidate = report;
          }
          // è·å–å€™é€‰å¯¹ä¿¡æ¯
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            // æ ¹æ®å€™é€‰ç±»å‹åˆ¤æ–­è¿æ¥æ–¹å¼
            const localType = getLocalCandidateType(report.localCandidateId, stats);
            const remoteType = getRemoteCandidateType(report.remoteCandidateId, stats);
            
            connectionType = determineConnectionType(localType, remoteType);
            
            // è·å–ç½‘ç»œå»¶è¿Ÿ
            if (report.currentRoundTripTime) {
              rtt = Math.round(report.currentRoundTripTime * 1000); // è½¬æ¢ä¸ºæ¯«ç§’
            }
          }
        });

        // æ›´æ–°UIæ˜¾ç¤º
        updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt);

      } catch (error) {
        console.error('è·å–è¿æ¥ç»Ÿè®¡å¤±è´¥:', error);
      }
    }

    // è·å–æœ¬åœ°å€™é€‰ç±»å‹
    function getLocalCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'local-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // è·å–è¿œç¨‹å€™é€‰ç±»å‹
    function getRemoteCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'remote-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // åˆ¤æ–­è¿æ¥ç±»å‹
    function determineConnectionType(localType, remoteType) {
      console.log('Local candidate type:', localType, 'Remote candidate type:', remoteType);
      
      // å¦‚æœä»»ä¸€æ–¹ä½¿ç”¨ relayï¼Œåˆ™æ˜¯ TURN è½¬å‘
      if (localType === 'relay' || remoteType === 'relay') {
        return 'ğŸ”„ TURN è½¬å‘';
      }
      
      // å¦‚æœéƒ½æ˜¯ hostï¼Œåˆ™æ˜¯ç›´æ¥è¿æ¥ï¼ˆå±€åŸŸç½‘ï¼‰
      if (localType === 'host' && remoteType === 'host') {
        return 'ğŸ  å±€åŸŸç½‘ç›´è¿';
      }
      
      // å¦‚æœæœ‰ srflxï¼ˆæœåŠ¡å™¨åå°„ï¼‰ï¼Œåˆ™æ˜¯é€šè¿‡ NAT
      if (localType === 'srflx' || remoteType === 'srflx') {
        return 'ğŸŒ NAT ç©¿é€';
      }
      
      // å¦‚æœæœ‰ prflxï¼ˆå¯¹ç­‰åå°„ï¼‰ï¼Œä¹Ÿæ˜¯ NAT ç©¿é€çš„ä¸€ç§
      if (localType === 'prflx' || remoteType === 'prflx') {
        return 'ğŸŒ NAT ç©¿é€ (å¯¹ç­‰åå°„)';
      }
      
      return `â“ æœªçŸ¥ (${localType}/${remoteType})`;
    }

    // æ›´æ–°è¿æ¥ä¿¡æ¯æ˜¾ç¤º
    function updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt) {
      document.getElementById('connectionType').textContent = connectionType;
      
      // æ›´æ–°è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator';
      if (connectionType.includes('æœªè¿æ¥')) {
        indicator.classList.add('disconnected');
      } else if (connectionType.includes('è¿æ¥ä¸­')) {
        indicator.classList.add('connecting');
      } else {
        indicator.classList.add('connected');
      }
      
      // æ›´æ–°æœ¬åœ°å€™é€‰ä¿¡æ¯
      if (localCandidate) {
        const localInfo = `${localCandidate.candidateType} (${localCandidate.protocol}) ${localCandidate.address}:${localCandidate.port}`;
        document.getElementById('localCandidate').textContent = localInfo;
      }
      
      // æ›´æ–°è¿œç¨‹å€™é€‰ä¿¡æ¯
      if (remoteCandidate) {
        const remoteInfo = `${remoteCandidate.candidateType} (${remoteCandidate.protocol}) ${remoteCandidate.address}:${remoteCandidate.port}`;
        document.getElementById('remoteCandidate').textContent = remoteInfo;
      }
      
      // æ›´æ–°ç½‘ç»œå»¶è¿Ÿ
      if (rtt !== null) {
        document.getElementById('networkDelay').textContent = `${rtt} ms`;
        
        // æ ¹æ®å»¶è¿Ÿæ·»åŠ é¢œè‰²æŒ‡ç¤º
        const delayElement = document.getElementById('networkDelay');
        if (rtt < 50) {
          delayElement.style.color = '#51cf66';
        } else if (rtt < 150) {
          delayElement.style.color = '#ffd43b';
        } else {
          delayElement.style.color = '#ff6b6b';
        }
      }
    }

    // å¼€å§‹è¿æ¥çŠ¶æ€ç›‘æ§
    function startConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
      }
      
      connectionStatsInterval = setInterval(() => {
        checkConnectionType();
      }, 2000); // æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡
    }

    // åœæ­¢è¿æ¥çŠ¶æ€ç›‘æ§
    function stopConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
        connectionStatsInterval = null;
      }
      
      // é‡ç½®æ˜¾ç¤º
      document.getElementById('connectionType').textContent = 'æœªè¿æ¥';
      document.getElementById('localCandidate').textContent = '-';
      document.getElementById('remoteCandidate').textContent = '-';
      document.getElementById('networkDelay').textContent = '-';
      document.getElementById('networkDelay').style.color = '';
      
      // æ›´æ–°è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator disconnected';
    }

    // ç½‘ç»œè¯Šæ–­åŠŸèƒ½
    async function runNetworkDiagnosis() {
      const resultDiv = document.getElementById('diagnosisResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨è¿›è¡Œç½‘ç»œè¯Šæ–­...</p>';
      
      try {
        // 1. æ£€æµ‹æœ¬åœ°ç½‘ç»œä¿¡æ¯
        const localInfo = await getLocalNetworkInfo();
        
        // 2. æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidate
        const iceResults = await testICECandidates();
        
        // 3. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
        const report = generateDiagnosisReport(localInfo, iceResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">è¯Šæ–­å¤±è´¥: ${error.message}</p>`;
      }
    }

    // è·å–æœ¬åœ°ç½‘ç»œä¿¡æ¯
    async function getLocalNetworkInfo() {
      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection();
        const info = {
          localIPs: [],
          networkType: 'unknown'
        };

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const candidate = event.candidate.candidate;
            const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
            if (ipMatch && !info.localIPs.includes(ipMatch[1])) {
              info.localIPs.push(ipMatch[1]);
            }
          } else {
            // ICE æ”¶é›†å®Œæˆ
            testPC.close();
            resolve(info);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
          testPC.close();
          resolve(info);
        }, 3000);
      });
    }

    // æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidates
    async function testICECandidates() {
      const results = {
        host: false,
        srflx: false,
        relay: false
      };

      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ]
        });

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const type = event.candidate.type;
            if (type === 'host') results.host = true;
            if (type === 'srflx') results.srflx = true;
            if (type === 'relay') results.relay = true;
          } else {
            testPC.close();
            resolve(results);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        setTimeout(() => {
          testPC.close();
          resolve(results);
        }, 5000);
      });
    }

    // ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
    function generateDiagnosisReport(localInfo, iceResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0;">';
      report += '<h4>ğŸ“Š ç½‘ç»œè¯Šæ–­æŠ¥å‘Š</h4>';
      
      // æœ¬åœ° IP ä¿¡æ¯
      report += '<p><strong>æœ¬åœ° IP åœ°å€:</strong></p><ul>';
      localInfo.localIPs.forEach(ip => {
        const isPrivate = isPrivateIP(ip);
        report += `<li>${ip} ${isPrivate ? '(å†…ç½‘)' : '(å…¬ç½‘)'}</li>`;
      });
      report += '</ul>';

      // ICE candidate æ”¯æŒæƒ…å†µ
      report += '<p><strong>ICE Candidate æ”¯æŒ:</strong></p><ul>';
      report += `<li>Host (æœ¬åœ°): ${iceResults.host ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Server Reflexive (STUN): ${iceResults.srflx ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Relay (TURN): ${iceResults.relay ? 'âœ“' : 'âœ—'}</li>`;
      report += '</ul>';

      // NAT ç±»å‹æ¨æ–­
      let natType = 'Unknown';
      if (iceResults.host && iceResults.srflx && iceResults.relay) {
        natType = 'Open Internet / Full Cone NAT';
      } else if (iceResults.srflx && iceResults.relay) {
        natType = 'Symmetric NAT (éœ€è¦ TURN)';
      } else if (iceResults.host && iceResults.srflx) {
        natType = 'Restricted Cone NAT';
      } else if (iceResults.relay) {
        natType = 'Strict NAT (ä»… TURN å¯ç”¨)';
      }

      report += `<p><strong>æ¨æ–­ NAT ç±»å‹:</strong> ${natType}</p>`;

      // å»ºè®®
      report += '<p><strong>è·¨ç½‘ç»œé€šä¿¡å»ºè®®:</strong></p><ul>';
      if (iceResults.relay) {
        report += '<li style="color: green;">âœ“ TURN æœåŠ¡å™¨å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡åº”è¯¥æ­£å¸¸</li>';
      } else {
        report += '<li style="color: red;">âœ— TURN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡å¯èƒ½å¤±è´¥</li>';
      }
      
      if (!iceResults.srflx) {
        report += '<li style="color: orange;">âš  STUN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œå¯èƒ½å½±å“ NAT ç©¿é€</li>';
      }

      report += '</ul></div>';
      return report;
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºå†…ç½‘ IP
    function isPrivateIP(ip) {
      const parts = ip.split('.').map(Number);
      return (
        (parts[0] === 10) ||
        (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === 192 && parts[1] === 168) ||
        (parts[0] === 127)
      );
    }

    // æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§
    async function testTurnServer() {
      const resultDiv = document.getElementById('turnTestResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§...</p>';
      
      try {
        const testPC = new RTCPeerConnection({
          iceServers: [
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ],
          iceTransportPolicy: 'relay' // å¼ºåˆ¶åªä½¿ç”¨ TURN
        });

        let turnCandidateFound = false;
        
        testPC.onicecandidate = (event) => {
          if (event.candidate && event.candidate.type === 'relay') {
            turnCandidateFound = true;
            resultDiv.innerHTML = '<p style="color: green;">âœ“ TURN æœåŠ¡å™¨è¿æ¥æˆåŠŸï¼</p>';
            console.log('TURN candidate found:', event.candidate);
          }
        };

        // åˆ›å»ºæ•°æ®é€šé“è§¦å‘ ICE æ”¶é›†
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // ç­‰å¾… ICE æ”¶é›†å®Œæˆ
        setTimeout(() => {
          if (!turnCandidateFound) {
            resultDiv.innerHTML = '<p style="color: red;">âœ— TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br/>1. æœåŠ¡å™¨åœ°å€æ˜¯å¦æ­£ç¡®<br/>2. ç”¨æˆ·åå¯†ç æ˜¯å¦æ­£ç¡®<br/>3. ç«¯å£æ˜¯å¦è¢«é˜²ç«å¢™é˜»å¡<br/>4. TURN æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ</p>';
          }
          testPC.close();
        }, 5000);

      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
        console.error('TURN test error:', error);
      }
    }

    // è·å–æ‘„åƒå¤´æµ
    async function getCameraStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šæ‘„åƒå¤´';
        return stream;
      } catch (error) {
        console.error('è·å–æ‘„åƒå¤´å¤±è´¥:', error);
        window.alert('è·å–æ‘„åƒå¤´å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // è·å–å±å¹•å…±äº«æµ
    async function getScreenStream() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šå±å¹•å…±äº«';
        return stream;
      } catch (error) {
        console.error('è·å–å±å¹•å…±äº«å¤±è´¥:', error);
        window.alert('è·å–å±å¹•å…±äº«å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // æ›¿æ¢åª’ä½“æµ
    async function replaceMediaStream(getStreamFunction) {
      try {
        const newStream = await getStreamFunction();
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œæ›¿æ¢è½¨é“
        if (peer_connection && currentStream) {
          // ç§»é™¤æ—§çš„è½¨é“
          const senders = peer_connection.getSenders();
          for (const sender of senders) {
            if (sender.track) {
              peer_connection.removeTrack(sender);
            }
          }
          
          // æ·»åŠ æ–°çš„è½¨é“
          newStream.getTracks().forEach(track => {
            peer_connection.addTrack(track, newStream);
          });
        }

        // åœæ­¢æ—§æµ
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        // æ›´æ–°æœ¬åœ°è§†é¢‘æ˜¾ç¤º
        document.getElementById('localVideo').srcObject = newStream;
        currentStream = newStream;

        // ç›‘å¬å±å¹•å…±äº«ç»“æŸäº‹ä»¶
        if (getStreamFunction === getScreenStream) {
          newStream.getVideoTracks()[0].addEventListener('ended', () => {
            console.log('å±å¹•å…±äº«å·²ç»“æŸï¼Œåˆ‡æ¢å›æ‘„åƒå¤´');
            replaceMediaStream(getCameraStream);
          });
        }

      } catch (error) {
        console.error('æ›¿æ¢åª’ä½“æµå¤±è´¥:', error);
      }
    }

    // åˆå§‹åŒ–WebRTCè¿æ¥
    function initializeWebRTC(stream) {
      currentStream = stream;
      
      // 2. åˆ›å»º WebRTC çš„ RTCPeerConnection å®ä¾‹ 
      // RTCPeerConnection æ˜¯ WebRTC çš„æ ¸å¿ƒæ¥å£ï¼Œç”¨äºå»ºç«‹ç‚¹å¯¹ç‚¹è¿æ¥
      // è´Ÿè´£å¤„ç†éŸ³è§†é¢‘æµçš„ä¼ è¾“ã€ICE åå•†ç­‰
      peer_connection = new RTCPeerConnection(
        {
          iceServers: [
            // **ä½ çš„ STUN æœåŠ¡å™¨é…ç½®**
            {
                urls: 'stun:coturn.meteor.matrix-net.tech:3478'
            },
            // **ä½ çš„ TURN æœåŠ¡å™¨é…ç½® - TCP**
            {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **ä½ çš„ TURN æœåŠ¡å™¨é…ç½® - UDP**
            {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **Google çš„å…¬å…± STUN æœåŠ¡å™¨ä½œä¸ºå¤‡ç”¨**
            {
                urls: 'stun:stun.l.google.com:19302'
            },
            // **Cloudflare STUN æœåŠ¡å™¨ä½œä¸ºå¤‡ç”¨**
            {
                urls: 'stun:stun.cloudflare.com:3478'
            }
          ],
          // æ ¹æ® forceRelay æ ‡å¿—å†³å®šæ˜¯å¦å¼ºåˆ¶ä½¿ç”¨ TURN
          iceTransportPolicy: forceRelay ? 'relay' : 'all'
        }
      )

      // 3. ç›‘å¬è¿œç«¯ track äº‹ä»¶ï¼ˆæ¥æ”¶åˆ°è¿œç«¯åª’ä½“æµæ—¶è§¦å‘ï¼‰
      peer_connection.ontrack = function (event) {
        // åªå¤„ç†è§†é¢‘è½¨é“ï¼Œå¿½ç•¥éŸ³é¢‘
        console.log('ontrack', event)
        if (event.track.kind === 'audio') {
          return
        }

        // åˆ›å»º video å…ƒç´ ç”¨äºæ’­æ”¾è¿œç«¯è§†é¢‘
        let el = document.createElement(event.track.kind)
        el.srcObject = event.streams[0]
        el.autoplay = true
        el.controls = true
        document.getElementById('remoteVideos').appendChild(el)

        // è¿œç«¯ track é™éŸ³æ—¶å°è¯•æ’­æ”¾ï¼ˆå…¼å®¹éƒ¨åˆ†æµè§ˆå™¨ç­–ç•¥ï¼‰
        event.track.onmute = function(event) {
          el.play()
        }

        // è¿œç«¯æµç§»é™¤ track æ—¶ï¼Œç§»é™¤ video å…ƒç´ 
        event.streams[0].onremovetrack = ({track}) => {
          if (el.parentNode) {
            el.parentNode.removeChild(el)
          }
        }
      }

      // 4. æ˜¾ç¤ºæœ¬åœ°è§†é¢‘æµ
      document.getElementById('localVideo').srcObject = stream
      // 5. å°†æœ¬åœ°éŸ³è§†é¢‘è½¨é“æ·»åŠ åˆ° RTCPeerConnection
      stream.getTracks().forEach(track => peer_connection.addTrack(track, stream))

      // 6. å»ºç«‹ WebSocket è¿æ¥åˆ°åç«¯ä¿¡ä»¤æœåŠ¡å™¨
      ws = new WebSocket("wss://meteor.matrix-net.tech/websocket")
      //ws = new WebSocket("ws://117.72.204.201:8080/websocket")

      // 7. ç›‘å¬ ICE candidate äº‹ä»¶ï¼Œå°†æœ¬åœ° candidate å‘é€ç»™åç«¯
      peer_connection.onicecandidate = e => {
        if (!e.candidate) {
          console.log('ICE gathering complete')
          return
        }
        // è®°å½• ICE candidate ç±»å‹ä»¥ä¾¿è°ƒè¯•
        console.log('ICE Candidate:', {
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidate: e.candidate.candidate
        })
        // å‘é€ candidate æ¶ˆæ¯ï¼Œdata å­—æ®µä¸ºå­—ç¬¦ä¸²åŒ–çš„ candidate å¯¹è±¡
        ws.send(JSON.stringify({event: 'candidate', data: JSON.stringify(e.candidate)}))
      }

      // ç›‘å¬ ICE è¿æ¥çŠ¶æ€å˜åŒ–
      peer_connection.oniceconnectionstatechange = () => {
        console.log('ICE Connection State:', peer_connection.iceConnectionState)
        const logDiv = document.getElementById('logs')
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] ICE è¿æ¥çŠ¶æ€: ${peer_connection.iceConnectionState}</p>`
        
        if (peer_connection.iceConnectionState === 'failed') {
          logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ ICE è¿æ¥å¤±è´¥ï¼å¯èƒ½åŸå› ï¼šTURNæœåŠ¡å™¨ä¸å¯ç”¨/ç½‘ç»œé˜²ç«å¢™é˜»å¡/NATç±»å‹ä¸å…¼å®¹</p>`
          stopConnectionMonitoring();
        } else if (peer_connection.iceConnectionState === 'connected') {
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] âœ… ICE è¿æ¥æˆåŠŸï¼</p>`
          startConnectionMonitoring(); // å¼€å§‹ç›‘æ§è¿æ¥ç±»å‹
        } else if (peer_connection.iceConnectionState === 'disconnected' || 
                   peer_connection.iceConnectionState === 'closed') {
          stopConnectionMonitoring();
        }
        
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
      peer_connection.onconnectionstatechange = () => {
        console.log('Connection State:', peer_connection.connectionState)
        const logDiv = document.getElementById('logs')
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] è¿æ¥çŠ¶æ€: ${peer_connection.connectionState}</p>`
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // 8. WebSocket å…³é—­æ—¶å¼¹çª—æç¤º
      ws.onclose = function(evt) {
        window.alert("Websocket has closed")
      }

      // 9. WebSocket æ”¶åˆ°æ¶ˆæ¯æ—¶çš„å¤„ç†é€»è¾‘
      ws.onmessage = function(evt) {
        // è§£ææ”¶åˆ°çš„ JSON æ¶ˆæ¯
        let msg = JSON.parse(evt.data)
        // è¾“å‡ºæ—¥å¿—åˆ°é¡µé¢
        console.log('ws message', msg)
        if (!msg) {
          return console.log('failed to parse msg')
        }

        // æ ¹æ® event å­—æ®µç±»å‹åˆ†æ”¯å¤„ç†
        switch (msg.event) {
          case 'paired':
            // æ”¶åˆ° 'paired' äº‹ä»¶ï¼Œæ ¹æ® data åˆ¤æ–­æ˜¯å¦ä¸ºå‘èµ·æ–¹
            // data ä¸º "true" è¡¨ç¤ºæ˜¯å‘èµ·æ–¹ï¼Œéœ€è¦åˆ›å»ºå¹¶å‘é€ offer
            if (msg.data === "true") {
              console.log("I am the initiator, creating offer...")
              peer_connection.createOffer().then(offer => {
                peer_connection.setLocalDescription(offer)
                ws.send(JSON.stringify({event: 'offer', data: JSON.stringify(offer)}))
              })
            } else {
              console.log("I am the receiver, waiting for offer...")
            }
            return

          case 'offer':
            // æ”¶åˆ°æœåŠ¡å™¨å‘æ¥çš„ offerï¼Œè§£æåè®¾ç½®ä¸ºè¿œç«¯æè¿°
            let offer = JSON.parse(msg.data)
            if (!offer) {
              return console.log('failed to parse offer')
            }
            console.log("Received offer, creating answer...")
            peer_connection.setRemoteDescription(offer)
            // åˆ›å»º answer å¹¶å‘é€å›æœåŠ¡å™¨
            peer_connection.createAnswer().then(answer => {
              peer_connection.setLocalDescription(answer)
              ws.send(JSON.stringify({event: 'answer', data: JSON.stringify(answer)}))
            })
            return
          
          case 'answer':
            // æ”¶åˆ°æœåŠ¡å™¨è½¬å‘çš„ answerï¼Œè§£æåè®¾ç½®ä¸ºè¿œç«¯æè¿°
            let answer = JSON.parse(msg.data)
            if (!answer) {
              return console.log('failed to parse answer')
            }
            peer_connection.setRemoteDescription(answer)
            return

          case 'candidate':
            // æ”¶åˆ°æœåŠ¡å™¨è½¬å‘çš„ candidateï¼Œè§£æååŠ å…¥ RTCPeerConnection
            let candidate = JSON.parse(msg.data)
            console.log('æ”¶åˆ°è¿œç«¯ ICE Candidate:', {
              type: candidate.type,
              protocol: candidate.protocol,
              address: candidate.address,
              port: candidate.port
            })
            // å¦‚æœ candidate è§£æå¤±è´¥ï¼Œè¾“å‡ºæ—¥å¿—å¹¶è¿”å›
            if (!candidate) {
              return console.log('failed to parse candidate')
            }
            peer_connection.addIceCandidate(candidate).catch(err => {
              console.error('æ·»åŠ  ICE candidate å¤±è´¥:', err)
            })
        }
      }

      // 10. WebSocket å‘ç”Ÿé”™è¯¯æ—¶è¾“å‡ºæ—¥å¿—
      ws.onerror = function(evt) {
        console.log("ERROR: " + evt.data)
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    document.addEventListener('DOMContentLoaded', function() {
      // TURN æœåŠ¡å™¨æµ‹è¯•æŒ‰é’®
      document.getElementById('testTurnBtn').addEventListener('click', testTurnServer);

      // ç½‘ç»œè¯Šæ–­æŒ‰é’®
      document.getElementById('diagnosisBtn').addEventListener('click', runNetworkDiagnosis);

      // å¼ºåˆ¶ TURN æ¨¡å¼æŒ‰é’®
      document.getElementById('forceRelayBtn').addEventListener('click', function() {
        forceRelay = !forceRelay;
        this.textContent = forceRelay ? 'ğŸ”„ å–æ¶ˆå¼ºåˆ¶ TURN' : 'ğŸš€ å¼ºåˆ¶ TURN æ¨¡å¼';
        this.className = forceRelay ? 'btn danger' : 'btn';
        
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] æ¨¡å¼åˆ‡æ¢: ${forceRelay ? 'å¼ºåˆ¶ TURN æ¨¡å¼' : 'è‡ªåŠ¨æ¨¡å¼'}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œé‡æ–°åˆå§‹åŒ–
        if (peer_connection && currentStream) {
          stopConnectionMonitoring(); // åœæ­¢æ—§è¿æ¥çš„ç›‘æ§
          peer_connection.close();
          initializeWebRTC(currentStream);
        }
      });

      // æ‘„åƒå¤´æŒ‰é’®äº‹ä»¶
      document.getElementById('cameraBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getCameraStream);
        } else {
          getCameraStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // å±å¹•å…±äº«æŒ‰é’®äº‹ä»¶
      document.getElementById('screenBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getScreenStream);
        } else {
          getScreenStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // é»˜è®¤ä½¿ç”¨æ‘„åƒå¤´
      getCameraStream().then(stream => {
        initializeWebRTC(stream);
      }).catch(console.error);
    });
  </script>
</html>
