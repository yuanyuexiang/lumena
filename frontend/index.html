<!DOCTYPE html>
<html>
  <!--
    SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
    SPDX-License-Identifier: MIT
  -->

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumena 视频通话</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: #333;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 30px;
        backdrop-filter: blur(10px);
      }

      h1 {
        text-align: center;
        color: #4a5568;
        margin-bottom: 30px;
        font-size: 2.5em;
        font-weight: 300;
      }

      .section {
        background: white;
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        border: 1px solid #e2e8f0;
      }

      .section h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3em;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .section h3::before {
        content: '';
        width: 4px;
        height: 20px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        border-radius: 2px;
      }

      .btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        margin: 5px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn.danger {
        background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      }

      .btn.danger:hover {
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
      }

      .btn.success {
        background: linear-gradient(135deg, #51cf66, #40c057);
        box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
      }

      .btn.success:hover {
        box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
      }

      .video-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .video-box {
        background: #f8f9fa;
        border-radius: 15px;
        padding: 15px;
        text-align: center;
        border: 2px solid #e9ecef;
      }

      video {
        width: 100%;
        max-width: 400px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .status-box {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 1px solid #dee2e6;
        border-radius: 15px;
        padding: 20px;
        margin: 15px 0;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding: 8px 0;
        border-bottom: 1px solid #e9ecef;
      }

      .status-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }

      .status-label {
        font-weight: 600;
        color: #495057;
      }

      .status-value {
        color: #6c757d;
        font-family: 'Courier New', monospace;
        background: rgba(255, 255, 255, 0.7);
        padding: 4px 8px;
        border-radius: 5px;
      }

      .logs {
        background: #1a1a1a;
        color: #00ff00;
        padding: 20px;
        border-radius: 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        margin-top: 15px;
      }

      .logs p {
        margin-bottom: 5px;
        line-height: 1.4;
      }

      .result-box {
        margin-top: 15px;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
      }

      .current-source {
        background: rgba(102, 126, 234, 0.1);
        color: #667eea;
        padding: 5px 12px;
        border-radius: 15px;
        font-weight: 500;
        margin-left: 10px;
      }

      .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
      }

      .icon {
        width: 20px;
        height: 20px;
        margin-right: 8px;
      }

      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
      }

      @media (max-width: 768px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }
        
        .container {
          padding: 15px;
          margin: 10px;
        }
        
        h1 {
          font-size: 2em;
        }
      }

      /* 动画效果 */
      .section {
        animation: slideInUp 0.6s ease;
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* 连接状态指示器 */
      .connection-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        animation: pulse 2s infinite;
      }

      .connection-indicator.connected {
        background-color: #51cf66;
      }

      .connection-indicator.disconnected {
        background-color: #ff6b6b;
      }

      .connection-indicator.connecting {
        background-color: #ffd43b;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>🎥 Lumena 视频通话</h1>
      
      <div class="grid-2">
        <div>
          <!-- 网络诊断区域 -->
          <div class="section">
            <h3>🔧 网络诊断</h3>
            <div class="button-group">
              <button id="testTurnBtn" class="btn">测试 TURN 服务器</button>
              <button id="diagnosisBtn" class="btn">网络诊断</button>
              <button id="priorityTestBtn" class="btn success">🚀 优先级连接测试</button>
              <button id="forceRelayBtn" class="btn">强制 TURN 模式</button>
            </div>
            <div id="turnTestResult" class="result-box"></div>
            <div id="diagnosisResult" class="result-box"></div>
            <div id="priorityTestResult" class="result-box"></div>
          </div>

          <!-- 媒体源选择 -->
          <div class="section">
            <h3>📹 媒体源选择</h3>
            <div class="button-group">
              <button id="cameraBtn" class="btn success">📷 使用摄像头</button>
              <button id="screenBtn" class="btn">🖥️ 屏幕共享</button>
            </div>
            <span id="currentSource" class="current-source">当前：未选择</span>
          </div>

          <!-- 连接状态 -->
          <div class="section">
            <h3>📡 连接状态</h3>
            <div class="status-box">
              <div class="status-item">
                <span class="status-label">连接方式:</span>
                <span class="status-value">
                  <span class="connection-indicator disconnected"></span>
                  <span id="connectionType">未连接</span>
                </span>
              </div>
              <div class="status-item">
                <span class="status-label">本地候选:</span>
                <span class="status-value" id="localCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">远程候选:</span>
                <span class="status-value" id="remoteCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">网络延迟:</span>
                <span class="status-value" id="networkDelay">-</span>
              </div>
            </div>
          </div>
        </div>

        <div>
          <!-- 视频区域 -->
          <div class="section">
            <h3>🎬 视频预览</h3>
            <div class="video-container">
              <div class="video-box">
                <h4>本地视频</h4>
                <video id="localVideo" width="320" height="240" autoplay muted></video>
              </div>
              <div class="video-box">
                <h4>远程视频</h4>
                <div id="remoteVideos"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 日志区域 -->
      <div class="section">
        <h3>📋 系统日志</h3>
        <div id="logs" class="logs"></div>
      </div>
    </div>
  </body>

  <script>
    let peer_connection;
    let ws;
    let currentStream;
    let forceRelay = false; // 是否强制使用 TURN
    let connectionStatsInterval; // 连接状态检测定时器
    let optimalConnectionMode = 'auto'; // 最优连接模式：'lan', 'nat', 'relay', 'auto'

    // 优先级连接测试
    async function runPriorityConnectionTest() {
      const resultDiv = document.getElementById('priorityTestResult');
      resultDiv.innerHTML = '<p>🔍 正在进行优先级连接测试...</p>';
      
      const testResults = {
        lan: { available: false, delay: null, quality: 0 },
        nat: { available: false, delay: null, quality: 0 },
        relay: { available: false, delay: null, quality: 0 }
      };

      try {
        // 1. 测试局域网直连 (Host candidates only)
        resultDiv.innerHTML += '<p>📍 1/3 测试局域网直连...</p>';
        testResults.lan = await testConnectionMode('host-only');
        
        // 2. 测试NAT穿透 (STUN)
        resultDiv.innerHTML += '<p>🌐 2/3 测试NAT穿透...</p>';
        testResults.nat = await testConnectionMode('nat-traversal');
        
        // 3. 测试TURN中继
        resultDiv.innerHTML += '<p>🔄 3/3 测试TURN中继...</p>';
        testResults.relay = await testConnectionMode('relay-only');
        
        // 生成测试报告和建议
        const report = generatePriorityTestReport(testResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML += `<p style="color: red;">测试失败: ${error.message}</p>`;
      }
    }

    // 测试特定连接模式
    async function testConnectionMode(mode) {
      return new Promise(async (resolve) => {
        let iceServers = [];
        let iceTransportPolicy = 'all';
        
        // 根据模式配置ICE服务器
        switch (mode) {
          case 'host-only':
            // 只使用本地候选，模拟局域网环境
            iceServers = [];
            iceTransportPolicy = 'all';
            break;
            
          case 'nat-traversal':
            // 使用STUN服务器进行NAT穿透
            iceServers = [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:coturn.meteor.matrix-net.tech:3478' }
            ];
            iceTransportPolicy = 'all';
            break;
            
          case 'relay-only':
            // 强制使用TURN中继
            iceServers = [
              {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
                username: 'matrix',
                credential: 'sual116y'
              },
              {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
                username: 'matrix',
                credential: 'sual116y'
              }
            ];
            iceTransportPolicy = 'relay';
            break;
        }

        const testPC = new RTCPeerConnection({
          iceServers,
          iceTransportPolicy
        });

        const result = {
          available: false,
          delay: null,
          quality: 0,
          candidateTypes: []
        };

        let startTime = Date.now();
        let candidatesFound = false;

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            candidatesFound = true;
            result.candidateTypes.push(event.candidate.type);
            
            // 计算ICE候选收集延迟
            if (!result.delay) {
              result.delay = Date.now() - startTime;
            }
            
            // 根据候选类型判断是否可用
            switch (mode) {
              case 'host-only':
                if (event.candidate.type === 'host') {
                  result.available = true;
                  result.quality = 100; // 局域网质量最高
                }
                break;
              case 'nat-traversal':
                if (event.candidate.type === 'srflx') {
                  result.available = true;
                  result.quality = 75; // NAT穿透质量中等
                }
                break;
              case 'relay-only':
                if (event.candidate.type === 'relay') {
                  result.available = true;
                  result.quality = 50; // 中继质量较低但稳定
                }
                break;
            }
          } else {
            // ICE收集完成
            testPC.close();
            resolve(result);
          }
        };

        // 创建数据通道触发ICE收集
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // 设置超时
        setTimeout(() => {
          if (!candidatesFound && !result.available) {
            result.available = false;
            result.delay = Date.now() - startTime;
          }
          testPC.close();
          resolve(result);
        }, 5000);
      });
    }

    // 生成优先级测试报告
    function generatePriorityTestReport(testResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 15px; margin: 10px 0; border-radius: 10px;">';
      report += '<h4>🎯 优先级连接测试报告</h4>';
      
      // 按优先级排序的连接方式
      const connectionMethods = [
        { key: 'lan', name: '🏠 局域网直连', priority: 1 },
        { key: 'nat', name: '🌐 NAT穿透', priority: 2 },
        { key: 'relay', name: '🔄 TURN中继', priority: 3 }
      ];
      
      report += '<table style="width: 100%; border-collapse: collapse; margin: 15px 0;">';
      report += '<tr style="background: #f8f9fa;"><th style="padding: 10px; border: 1px solid #dee2e6;">优先级</th><th style="padding: 10px; border: 1px solid #dee2e6;">连接方式</th><th style="padding: 10px; border: 1px solid #dee2e6;">状态</th><th style="padding: 10px; border: 1px solid #dee2e6;">延迟</th><th style="padding: 10px; border: 1px solid #dee2e6;">质量评分</th></tr>';
      
      let recommendedMode = null;
      let bestQuality = 0;
      
      connectionMethods.forEach(method => {
        const result = testResults[method.key];
        const status = result.available ? '✅ 可用' : '❌ 不可用';
        const delay = result.delay ? `${result.delay}ms` : '-';
        const quality = result.available ? `${result.quality}/100` : '-';
        
        const rowColor = result.available ? '#d4edda' : '#f8d7da';
        report += `<tr style="background: ${rowColor};"><td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${method.priority}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${method.name}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${status}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${delay}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${quality}</td></tr>`;
        
        // 找到最优连接方式（按优先级和质量）
        if (result.available && (!recommendedMode || method.priority < connectionMethods.find(m => m.key === recommendedMode).priority)) {
          recommendedMode = method.key;
          bestQuality = result.quality;
        }
      });
      
      report += '</table>';
      
      // 推荐方案
      if (recommendedMode) {
        const recommendedMethod = connectionMethods.find(m => m.key === recommendedMode);
        optimalConnectionMode = recommendedMode; // 保存最优模式
        
        report += `<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
        report += `<h5 style="color: #0c5460; margin: 0 0 10px 0;">💡 推荐连接方式</h5>`;
        report += `<p style="margin: 0;"><strong>${recommendedMethod.name}</strong> - 质量评分: ${bestQuality}/100</p>`;
        report += `<button id="applyOptimalMode" class="btn success" style="margin-top: 10px;">🚀 应用最优配置</button>`;
        report += `</div>`;
      } else {
        report += `<div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
        report += `<h5 style="color: #721c24; margin: 0 0 10px 0;">⚠️ 连接问题</h5>`;
        report += `<p style="margin: 0;">所有连接方式均不可用，请检查网络配置和TURN服务器状态。</p>`;
        report += `</div>`;
      }
      
      report += '</div>';
      return report;
    }

    // 应用最优连接模式
    function applyOptimalConnectionMode() {
      if (!optimalConnectionMode || optimalConnectionMode === 'auto') return;
      
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      
      switch (optimalConnectionMode) {
        case 'lan':
          // 应用局域网直连配置
          forceRelay = false;
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] 🏠 已切换到局域网直连模式</p>`;
          break;
        case 'nat':
          // 应用NAT穿透配置
          forceRelay = false;
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] 🌐 已切换到NAT穿透模式</p>`;
          break;
        case 'relay':
          // 应用TURN中继配置
          forceRelay = true;
          document.getElementById('forceRelayBtn').textContent = '🔄 取消强制 TURN';
          document.getElementById('forceRelayBtn').className = 'btn danger';
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] 🔄 已切换到TURN中继模式</p>`;
          break;
      }
      
      logDiv.scrollTop = logDiv.scrollHeight;
      
      // 如果已有连接，重新初始化
      if (peer_connection && currentStream) {
        stopConnectionMonitoring();
        peer_connection.close();
        initializeWebRTC(currentStream);
      }
    }

    // 检测连接类型和状态
    async function checkConnectionType() {
      if (!peer_connection) return;

      try {
        const stats = await peer_connection.getStats();
        let localCandidate = null;
        let remoteCandidate = null;
        let connectionType = '未知';
        let rtt = null;

        stats.forEach(report => {
          // 获取本地候选信息
          if (report.type === 'local-candidate') {
            localCandidate = report;
          }
          // 获取远程候选信息
          if (report.type === 'remote-candidate') {
            remoteCandidate = report;
          }
          // 获取候选对信息
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            // 根据候选类型判断连接方式
            const localType = getLocalCandidateType(report.localCandidateId, stats);
            const remoteType = getRemoteCandidateType(report.remoteCandidateId, stats);
            
            connectionType = determineConnectionType(localType, remoteType);
            
            // 获取网络延迟
            if (report.currentRoundTripTime) {
              rtt = Math.round(report.currentRoundTripTime * 1000); // 转换为毫秒
            }
          }
        });

        // 更新UI显示
        updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt);

      } catch (error) {
        console.error('获取连接统计失败:', error);
      }
    }

    // 获取本地候选类型
    function getLocalCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'local-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // 获取远程候选类型
    function getRemoteCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'remote-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // 判断连接类型
    function determineConnectionType(localType, remoteType) {
      console.log('Local candidate type:', localType, 'Remote candidate type:', remoteType);
      
      // 如果任一方使用 relay，则是 TURN 转发
      if (localType === 'relay' || remoteType === 'relay') {
        return '🔄 TURN 转发';
      }
      
      // 如果都是 host，则是直接连接（局域网）
      if (localType === 'host' && remoteType === 'host') {
        return '🏠 局域网直连';
      }
      
      // 如果有 srflx（服务器反射），则是通过 NAT
      if (localType === 'srflx' || remoteType === 'srflx') {
        return '🌐 NAT 穿透';
      }
      
      // 如果有 prflx（对等反射），也是 NAT 穿透的一种
      if (localType === 'prflx' || remoteType === 'prflx') {
        return '🌐 NAT 穿透 (对等反射)';
      }
      
      return `❓ 未知 (${localType}/${remoteType})`;
    }

    // 更新连接信息显示
    function updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt) {
      document.getElementById('connectionType').textContent = connectionType;
      
      // 更新连接状态指示器
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator';
      if (connectionType.includes('未连接')) {
        indicator.classList.add('disconnected');
      } else if (connectionType.includes('连接中')) {
        indicator.classList.add('connecting');
      } else {
        indicator.classList.add('connected');
      }
      
      // 更新本地候选信息
      if (localCandidate) {
        const localInfo = `${localCandidate.candidateType} (${localCandidate.protocol}) ${localCandidate.address}:${localCandidate.port}`;
        document.getElementById('localCandidate').textContent = localInfo;
      }
      
      // 更新远程候选信息
      if (remoteCandidate) {
        const remoteInfo = `${remoteCandidate.candidateType} (${remoteCandidate.protocol}) ${remoteCandidate.address}:${remoteCandidate.port}`;
        document.getElementById('remoteCandidate').textContent = remoteInfo;
      }
      
      // 更新网络延迟
      if (rtt !== null) {
        document.getElementById('networkDelay').textContent = `${rtt} ms`;
        
        // 根据延迟添加颜色指示
        const delayElement = document.getElementById('networkDelay');
        if (rtt < 50) {
          delayElement.style.color = '#51cf66';
        } else if (rtt < 150) {
          delayElement.style.color = '#ffd43b';
        } else {
          delayElement.style.color = '#ff6b6b';
        }
      }
    }

    // 开始连接状态监控
    function startConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
      }
      
      connectionStatsInterval = setInterval(() => {
        checkConnectionType();
      }, 2000); // 每2秒检查一次
    }

    // 停止连接状态监控
    function stopConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
        connectionStatsInterval = null;
      }
      
      // 重置显示
      document.getElementById('connectionType').textContent = '未连接';
      document.getElementById('localCandidate').textContent = '-';
      document.getElementById('remoteCandidate').textContent = '-';
      document.getElementById('networkDelay').textContent = '-';
      document.getElementById('networkDelay').style.color = '';
      
      // 更新连接状态指示器
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator disconnected';
    }

    // 网络诊断功能
    async function runNetworkDiagnosis() {
      const resultDiv = document.getElementById('diagnosisResult');
      resultDiv.innerHTML = '<p>正在进行网络诊断...</p>';
      
      try {
        // 1. 检测本地网络信息
        const localInfo = await getLocalNetworkInfo();
        
        // 2. 测试不同类型的 ICE candidate
        const iceResults = await testICECandidates();
        
        // 3. 生成诊断报告
        const report = generateDiagnosisReport(localInfo, iceResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">诊断失败: ${error.message}</p>`;
      }
    }

    // 获取本地网络信息
    async function getLocalNetworkInfo() {
      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection();
        const info = {
          localIPs: [],
          networkType: 'unknown'
        };

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const candidate = event.candidate.candidate;
            const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
            if (ipMatch && !info.localIPs.includes(ipMatch[1])) {
              info.localIPs.push(ipMatch[1]);
            }
          } else {
            // ICE 收集完成
            testPC.close();
            resolve(info);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        // 超时处理
        setTimeout(() => {
          testPC.close();
          resolve(info);
        }, 3000);
      });
    }

    // 测试不同类型的 ICE candidates
    async function testICECandidates() {
      const results = {
        host: false,
        srflx: false,
        relay: false
      };

      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ]
        });

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const type = event.candidate.type;
            if (type === 'host') results.host = true;
            if (type === 'srflx') results.srflx = true;
            if (type === 'relay') results.relay = true;
          } else {
            testPC.close();
            resolve(results);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        setTimeout(() => {
          testPC.close();
          resolve(results);
        }, 5000);
      });
    }

    // 生成诊断报告
    function generateDiagnosisReport(localInfo, iceResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0;">';
      report += '<h4>📊 网络诊断报告</h4>';
      
      // 本地 IP 信息
      report += '<p><strong>本地 IP 地址:</strong></p><ul>';
      localInfo.localIPs.forEach(ip => {
        const isPrivate = isPrivateIP(ip);
        report += `<li>${ip} ${isPrivate ? '(内网)' : '(公网)'}</li>`;
      });
      report += '</ul>';

      // ICE candidate 支持情况
      report += '<p><strong>ICE Candidate 支持:</strong></p><ul>';
      report += `<li>Host (本地): ${iceResults.host ? '✓' : '✗'}</li>`;
      report += `<li>Server Reflexive (STUN): ${iceResults.srflx ? '✓' : '✗'}</li>`;
      report += `<li>Relay (TURN): ${iceResults.relay ? '✓' : '✗'}</li>`;
      report += '</ul>';

      // NAT 类型推断
      let natType = 'Unknown';
      if (iceResults.host && iceResults.srflx && iceResults.relay) {
        natType = 'Open Internet / Full Cone NAT';
      } else if (iceResults.srflx && iceResults.relay) {
        natType = 'Symmetric NAT (需要 TURN)';
      } else if (iceResults.host && iceResults.srflx) {
        natType = 'Restricted Cone NAT';
      } else if (iceResults.relay) {
        natType = 'Strict NAT (仅 TURN 可用)';
      }

      report += `<p><strong>推断 NAT 类型:</strong> ${natType}</p>`;

      // 建议
      report += '<p><strong>跨网络通信建议:</strong></p><ul>';
      if (iceResults.relay) {
        report += '<li style="color: green;">✓ TURN 服务器可用，跨网络通信应该正常</li>';
      } else {
        report += '<li style="color: red;">✗ TURN 服务器不可用，跨网络通信可能失败</li>';
      }
      
      if (!iceResults.srflx) {
        report += '<li style="color: orange;">⚠ STUN 服务器不可用，可能影响 NAT 穿透</li>';
      }

      report += '</ul></div>';
      return report;
    }

    // 判断是否为内网 IP
    function isPrivateIP(ip) {
      const parts = ip.split('.').map(Number);
      return (
        (parts[0] === 10) ||
        (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === 192 && parts[1] === 168) ||
        (parts[0] === 127)
      );
    }

    // 测试 TURN 服务器连通性
    async function testTurnServer() {
      const resultDiv = document.getElementById('turnTestResult');
      resultDiv.innerHTML = '<p>正在测试 TURN 服务器连通性...</p>';
      
      try {
        const testPC = new RTCPeerConnection({
          iceServers: [
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ],
          iceTransportPolicy: 'relay' // 强制只使用 TURN
        });

        let turnCandidateFound = false;
        
        testPC.onicecandidate = (event) => {
          if (event.candidate && event.candidate.type === 'relay') {
            turnCandidateFound = true;
            resultDiv.innerHTML = '<p style="color: green;">✓ TURN 服务器连接成功！</p>';
            console.log('TURN candidate found:', event.candidate);
          }
        };

        // 创建数据通道触发 ICE 收集
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // 等待 ICE 收集完成
        setTimeout(() => {
          if (!turnCandidateFound) {
            resultDiv.innerHTML = '<p style="color: red;">✗ TURN 服务器连接失败！请检查：<br/>1. 服务器地址是否正确<br/>2. 用户名密码是否正确<br/>3. 端口是否被防火墙阻塞<br/>4. TURN 服务器是否正常运行</p>';
          }
          testPC.close();
        }, 5000);

      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">测试失败: ${error.message}</p>`;
        console.error('TURN test error:', error);
      }
    }

    // 获取摄像头流
    async function getCameraStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = '当前：摄像头';
        return stream;
      } catch (error) {
        console.error('获取摄像头失败:', error);
        window.alert('获取摄像头失败: ' + error.message);
        throw error;
      }
    }

    // 获取屏幕共享流
    async function getScreenStream() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = '当前：屏幕共享';
        return stream;
      } catch (error) {
        console.error('获取屏幕共享失败:', error);
        window.alert('获取屏幕共享失败: ' + error.message);
        throw error;
      }
    }

    // 替换媒体流
    async function replaceMediaStream(getStreamFunction) {
      try {
        const newStream = await getStreamFunction();
        
        // 如果已有连接，替换轨道
        if (peer_connection && currentStream) {
          // 移除旧的轨道
          const senders = peer_connection.getSenders();
          for (const sender of senders) {
            if (sender.track) {
              peer_connection.removeTrack(sender);
            }
          }
          
          // 添加新的轨道
          newStream.getTracks().forEach(track => {
            peer_connection.addTrack(track, newStream);
          });
        }

        // 停止旧流
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        // 更新本地视频显示
        document.getElementById('localVideo').srcObject = newStream;
        currentStream = newStream;

        // 监听屏幕共享结束事件
        if (getStreamFunction === getScreenStream) {
          newStream.getVideoTracks()[0].addEventListener('ended', () => {
            console.log('屏幕共享已结束，切换回摄像头');
            replaceMediaStream(getCameraStream);
          });
        }

      } catch (error) {
        console.error('替换媒体流失败:', error);
      }
    }

    // 初始化WebRTC连接
    function initializeWebRTC(stream) {
      currentStream = stream;
      
      // 根据最优连接模式配置ICE服务器
      let iceServers = [];
      let iceTransportPolicy = 'all';
      
      if (optimalConnectionMode === 'lan') {
        // 局域网模式：尽量使用本地候选
        iceServers = [
          { urls: 'stun:coturn.meteor.matrix-net.tech:3478' }
        ];
      } else if (optimalConnectionMode === 'relay' || forceRelay) {
        // 中继模式：强制使用TURN
        iceServers = [
          {
            urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
            username: 'matrix',
            credential: 'sual116y'
          },
          {
            urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
            username: 'matrix',
            credential: 'sual116y'
          }
        ];
        iceTransportPolicy = 'relay';
      } else {
        // 默认模式或NAT穿透模式：使用完整配置
        iceServers = [
          { urls: 'stun:coturn.meteor.matrix-net.tech:3478' },
          {
            urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
            username: 'matrix',
            credential: 'sual116y'
          },
          {
            urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
            username: 'matrix',
            credential: 'sual116y'
          },
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ];
        iceTransportPolicy = forceRelay ? 'relay' : 'all';
      }
      
      // 创建 WebRTC 的 RTCPeerConnection 实例
      peer_connection = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy
      })

      // 记录当前使用的配置
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      logDiv.innerHTML += `<p>[${timestamp}] 🔧 使用连接模式: ${optimalConnectionMode === 'auto' ? '自动' : optimalConnectionMode} (${iceTransportPolicy})</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;

      // 3. 监听远端 track 事件（接收到远端媒体流时触发）
      peer_connection.ontrack = function (event) {
        // 只处理视频轨道，忽略音频
        console.log('ontrack', event)
        if (event.track.kind === 'audio') {
          return
        }

        // 创建 video 元素用于播放远端视频
        let el = document.createElement(event.track.kind)
        el.srcObject = event.streams[0]
        el.autoplay = true
        el.controls = true
        document.getElementById('remoteVideos').appendChild(el)

        // 远端 track 静音时尝试播放（兼容部分浏览器策略）
        event.track.onmute = function(event) {
          el.play()
        }

        // 远端流移除 track 时，移除 video 元素
        event.streams[0].onremovetrack = ({track}) => {
          if (el.parentNode) {
            el.parentNode.removeChild(el)
          }
        }
      }

      // 4. 显示本地视频流
      document.getElementById('localVideo').srcObject = stream
      // 5. 将本地音视频轨道添加到 RTCPeerConnection
      stream.getTracks().forEach(track => peer_connection.addTrack(track, stream))

      // 6. 建立 WebSocket 连接到后端信令服务器
      ws = new WebSocket("wss://meteor.matrix-net.tech/websocket")
      //ws = new WebSocket("ws://117.72.204.201:8080/websocket")

      // 7. 监听 ICE candidate 事件，将本地 candidate 发送给后端
      peer_connection.onicecandidate = e => {
        if (!e.candidate) {
          console.log('ICE gathering complete')
          return
        }
        // 记录 ICE candidate 类型以便调试
        console.log('ICE Candidate:', {
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidate: e.candidate.candidate
        })
        // 发送 candidate 消息，data 字段为字符串化的 candidate 对象
        ws.send(JSON.stringify({event: 'candidate', data: JSON.stringify(e.candidate)}))
      }

      // 监听 ICE 连接状态变化
      peer_connection.oniceconnectionstatechange = () => {
        console.log('ICE Connection State:', peer_connection.iceConnectionState)
        const logDiv = document.getElementById('logs')
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] ICE 连接状态: ${peer_connection.iceConnectionState}</p>`
        
        if (peer_connection.iceConnectionState === 'failed') {
          logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] ❌ ICE 连接失败！可能原因：TURN服务器不可用/网络防火墙阻塞/NAT类型不兼容</p>`
          stopConnectionMonitoring();
        } else if (peer_connection.iceConnectionState === 'connected') {
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ✅ ICE 连接成功！</p>`
          startConnectionMonitoring(); // 开始监控连接类型
        } else if (peer_connection.iceConnectionState === 'disconnected' || 
                   peer_connection.iceConnectionState === 'closed') {
          stopConnectionMonitoring();
        }
        
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // 监听连接状态变化
      peer_connection.onconnectionstatechange = () => {
        console.log('Connection State:', peer_connection.connectionState)
        const logDiv = document.getElementById('logs')
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] 连接状态: ${peer_connection.connectionState}</p>`
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      // 8. WebSocket 关闭时弹窗提示
      ws.onclose = function(evt) {
        window.alert("Websocket has closed")
      }

      // 9. WebSocket 收到消息时的处理逻辑
      ws.onmessage = function(evt) {
        // 解析收到的 JSON 消息
        let msg = JSON.parse(evt.data)
        // 输出日志到页面
        console.log('ws message', msg)
        if (!msg) {
          return console.log('failed to parse msg')
        }

        // 根据 event 字段类型分支处理
        switch (msg.event) {
          case 'paired':
            // 收到 'paired' 事件，根据 data 判断是否为发起方
            // data 为 "true" 表示是发起方，需要创建并发送 offer
            if (msg.data === "true") {
              console.log("I am the initiator, creating offer...")
              peer_connection.createOffer().then(offer => {
                peer_connection.setLocalDescription(offer)
                ws.send(JSON.stringify({event: 'offer', data: JSON.stringify(offer)}))
              })
            } else {
              console.log("I am the receiver, waiting for offer...")
            }
            return

          case 'offer':
            // 收到服务器发来的 offer，解析后设置为远端描述
            let offer = JSON.parse(msg.data)
            if (!offer) {
              return console.log('failed to parse offer')
            }
            console.log("Received offer, creating answer...")
            peer_connection.setRemoteDescription(offer)
            // 创建 answer 并发送回服务器
            peer_connection.createAnswer().then(answer => {
              peer_connection.setLocalDescription(answer)
              ws.send(JSON.stringify({event: 'answer', data: JSON.stringify(answer)}))
            })
            return
          
          case 'answer':
            // 收到服务器转发的 answer，解析后设置为远端描述
            let answer = JSON.parse(msg.data)
            if (!answer) {
              return console.log('failed to parse answer')
            }
            peer_connection.setRemoteDescription(answer)
            return

          case 'candidate':
            // 收到服务器转发的 candidate，解析后加入 RTCPeerConnection
            let candidate = JSON.parse(msg.data)
            console.log('收到远端 ICE Candidate:', {
              type: candidate.type,
              protocol: candidate.protocol,
              address: candidate.address,
              port: candidate.port
            })
            // 如果 candidate 解析失败，输出日志并返回
            if (!candidate) {
              return console.log('failed to parse candidate')
            }
            peer_connection.addIceCandidate(candidate).catch(err => {
              console.error('添加 ICE candidate 失败:', err)
            })
        }
      }

      // 10. WebSocket 发生错误时输出日志
      ws.onerror = function(evt) {
        console.log("ERROR: " + evt.data)
      }
    }

    // 页面加载完成后设置事件监听器
    document.addEventListener('DOMContentLoaded', function() {
      // TURN 服务器测试按钮
      document.getElementById('testTurnBtn').addEventListener('click', testTurnServer);

      // 网络诊断按钮
      document.getElementById('diagnosisBtn').addEventListener('click', runNetworkDiagnosis);

      // 优先级连接测试按钮
      document.getElementById('priorityTestBtn').addEventListener('click', runPriorityConnectionTest);

      // 动态绑定"应用最优配置"按钮（因为是动态生成的）
      document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'applyOptimalMode') {
          applyOptimalConnectionMode();
        }
      });

      // 强制 TURN 模式按钮
      document.getElementById('forceRelayBtn').addEventListener('click', function() {
        forceRelay = !forceRelay;
        this.textContent = forceRelay ? '🔄 取消强制 TURN' : '🚀 强制 TURN 模式';
        this.className = forceRelay ? 'btn danger' : 'btn';
        
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] 模式切换: ${forceRelay ? '强制 TURN 模式' : '自动模式'}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // 如果已有连接，重新初始化
        if (peer_connection && currentStream) {
          stopConnectionMonitoring(); // 停止旧连接的监控
          peer_connection.close();
          initializeWebRTC(currentStream);
        }
      });

      // 摄像头按钮事件
      document.getElementById('cameraBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getCameraStream);
        } else {
          getCameraStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // 屏幕共享按钮事件
      document.getElementById('screenBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getScreenStream);
        } else {
          getScreenStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // 默认使用摄像头
      getCameraStream().then(stream => {
        initializeWebRTC(stream);
      }).catch(console.error);
    });
  </script>
</html>
