<!DOCTYPE html>
<html>
  <!--
    SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
    SPDX-License-Identifier: MIT
  -->

  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <h3> TURN æœåŠ¡å™¨æµ‹è¯• </h3>
    <button id="testTurnBtn">æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§</button>
    <div id="turnTestResult"></div>
    <br />

    <h3> ç½‘ç»œè¯Šæ–­ </h3>
    <button id="diagnosisBtn">å¼€å§‹ç½‘ç»œè¯Šæ–­</button>
    <button id="forceRelayBtn">å¼ºåˆ¶ä½¿ç”¨ TURN æ¨¡å¼</button>
    <div id="diagnosisResult"></div>
    <br />

    <h3> åª’ä½“æºé€‰æ‹© </h3>
    <button id="cameraBtn">ä½¿ç”¨æ‘„åƒå¤´</button>
    <button id="screenBtn">å±å¹•å…±äº«</button>
    <span id="currentSource">å½“å‰ï¼šæœªé€‰æ‹©</span>
    <br /><br />

    <h3> æœ¬åœ°è§†é¢‘ </h3>
    <video id="localVideo" width="320" height="240" autoplay muted></video> <br />

    <h3> è¿œç¨‹è§†é¢‘ </h3>
    <div id="remoteVideos"></div> <br />

    <h3> æ—¥å¿— </h3>
    <div id="logs"></div>
  </body>

  <script>
    let peer_connection;
    let ws;
    let currentStream;
    let forceRelay = false; // æ˜¯å¦å¼ºåˆ¶ä½¿ç”¨ TURN

    // ç½‘ç»œè¯Šæ–­åŠŸèƒ½
    async function runNetworkDiagnosis() {
      const resultDiv = document.getElementById('diagnosisResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨è¿›è¡Œç½‘ç»œè¯Šæ–­...</p>';
      
      try {
        // 1. æ£€æµ‹æœ¬åœ°ç½‘ç»œä¿¡æ¯
        const localInfo = await getLocalNetworkInfo();
        
        // 2. æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidate
        const iceResults = await testICECandidates();
        
        // 3. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
        const report = generateDiagnosisReport(localInfo, iceResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">è¯Šæ–­å¤±è´¥: ${error.message}</p>`;
      }
    }

    // è·å–æœ¬åœ°ç½‘ç»œä¿¡æ¯
    async function getLocalNetworkInfo() {
      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection();
        const info = {
          localIPs: [],
          networkType: 'unknown'
        };

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const candidate = event.candidate.candidate;
            const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
            if (ipMatch && !info.localIPs.includes(ipMatch[1])) {
              info.localIPs.push(ipMatch[1]);
            }
          } else {
            // ICE æ”¶é›†å®Œæˆ
            testPC.close();
            resolve(info);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
          testPC.close();
          resolve(info);
        }, 3000);
      });
    }

    // æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidates
    async function testICECandidates() {
      const results = {
        host: false,
        srflx: false,
        relay: false
      };

      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:117.72.204.201:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ]
        });

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const type = event.candidate.type;
            if (type === 'host') results.host = true;
            if (type === 'srflx') results.srflx = true;
            if (type === 'relay') results.relay = true;
          } else {
            testPC.close();
            resolve(results);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        setTimeout(() => {
          testPC.close();
          resolve(results);
        }, 5000);
      });
    }

    // ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
    function generateDiagnosisReport(localInfo, iceResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0;">';
      report += '<h4>ğŸ“Š ç½‘ç»œè¯Šæ–­æŠ¥å‘Š</h4>';
      
      // æœ¬åœ° IP ä¿¡æ¯
      report += '<p><strong>æœ¬åœ° IP åœ°å€:</strong></p><ul>';
      localInfo.localIPs.forEach(ip => {
        const isPrivate = isPrivateIP(ip);
        report += `<li>${ip} ${isPrivate ? '(å†…ç½‘)' : '(å…¬ç½‘)'}</li>`;
      });
      report += '</ul>';

      // ICE candidate æ”¯æŒæƒ…å†µ
      report += '<p><strong>ICE Candidate æ”¯æŒ:</strong></p><ul>';
      report += `<li>Host (æœ¬åœ°): ${iceResults.host ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Server Reflexive (STUN): ${iceResults.srflx ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Relay (TURN): ${iceResults.relay ? 'âœ“' : 'âœ—'}</li>`;
      report += '</ul>';

      // NAT ç±»å‹æ¨æ–­
      let natType = 'Unknown';
      if (iceResults.host && iceResults.srflx && iceResults.relay) {
        natType = 'Open Internet / Full Cone NAT';
      } else if (iceResults.srflx && iceResults.relay) {
        natType = 'Symmetric NAT (éœ€è¦ TURN)';
      } else if (iceResults.host && iceResults.srflx) {
        natType = 'Restricted Cone NAT';
      } else if (iceResults.relay) {
        natType = 'Strict NAT (ä»… TURN å¯ç”¨)';
      }

      report += `<p><strong>æ¨æ–­ NAT ç±»å‹:</strong> ${natType}</p>`;

      // å»ºè®®
      report += '<p><strong>è·¨ç½‘ç»œé€šä¿¡å»ºè®®:</strong></p><ul>';
      if (iceResults.relay) {
        report += '<li style="color: green;">âœ“ TURN æœåŠ¡å™¨å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡åº”è¯¥æ­£å¸¸</li>';
      } else {
        report += '<li style="color: red;">âœ— TURN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡å¯èƒ½å¤±è´¥</li>';
      }
      
      if (!iceResults.srflx) {
        report += '<li style="color: orange;">âš  STUN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œå¯èƒ½å½±å“ NAT ç©¿é€</li>';
      }

      report += '</ul></div>';
      return report;
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºå†…ç½‘ IP
    function isPrivateIP(ip) {
      const parts = ip.split('.').map(Number);
      return (
        (parts[0] === 10) ||
        (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === 192 && parts[1] === 168) ||
        (parts[0] === 127)
      );
    }

    // æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§
    async function testTurnServer() {
      const resultDiv = document.getElementById('turnTestResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§...</p>';
      
      try {
        const testPC = new RTCPeerConnection({
          iceServers: [
            {
              urls: 'turn:117.72.204.201:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            },
            {
              urls: 'turn:117.72.204.201:3478?transport=udp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ],
          iceTransportPolicy: 'relay' // å¼ºåˆ¶åªä½¿ç”¨ TURN
        });

        let turnCandidateFound = false;
        
        testPC.onicecandidate = (event) => {
          if (event.candidate && event.candidate.type === 'relay') {
            turnCandidateFound = true;
            resultDiv.innerHTML = '<p style="color: green;">âœ“ TURN æœåŠ¡å™¨è¿æ¥æˆåŠŸï¼</p>';
            console.log('TURN candidate found:', event.candidate);
          }
        };

        // åˆ›å»ºæ•°æ®é€šé“è§¦å‘ ICE æ”¶é›†
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // ç­‰å¾… ICE æ”¶é›†å®Œæˆ
        setTimeout(() => {
          if (!turnCandidateFound) {
            resultDiv.innerHTML = '<p style="color: red;">âœ— TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br/>1. æœåŠ¡å™¨åœ°å€æ˜¯å¦æ­£ç¡®<br/>2. ç”¨æˆ·åå¯†ç æ˜¯å¦æ­£ç¡®<br/>3. ç«¯å£æ˜¯å¦è¢«é˜²ç«å¢™é˜»å¡<br/>4. TURN æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ</p>';
          }
          testPC.close();
        }, 5000);

      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
        console.error('TURN test error:', error);
      }
    }

    // è·å–æ‘„åƒå¤´æµ
    async function getCameraStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šæ‘„åƒå¤´';
        return stream;
      } catch (error) {
        console.error('è·å–æ‘„åƒå¤´å¤±è´¥:', error);
        window.alert('è·å–æ‘„åƒå¤´å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // è·å–å±å¹•å…±äº«æµ
    async function getScreenStream() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šå±å¹•å…±äº«';
        return stream;
      } catch (error) {
        console.error('è·å–å±å¹•å…±äº«å¤±è´¥:', error);
        window.alert('è·å–å±å¹•å…±äº«å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // æ›¿æ¢åª’ä½“æµ
    async function replaceMediaStream(getStreamFunction) {
      try {
        const newStream = await getStreamFunction();
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œæ›¿æ¢è½¨é“
        if (peer_connection && currentStream) {
          // ç§»é™¤æ—§çš„è½¨é“
          const senders = peer_connection.getSenders();
          for (const sender of senders) {
            if (sender.track) {
              peer_connection.removeTrack(sender);
            }
          }
          
          // æ·»åŠ æ–°çš„è½¨é“
          newStream.getTracks().forEach(track => {
            peer_connection.addTrack(track, newStream);
          });
        }

        // åœæ­¢æ—§æµ
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        // æ›´æ–°æœ¬åœ°è§†é¢‘æ˜¾ç¤º
        document.getElementById('localVideo').srcObject = newStream;
        currentStream = newStream;

        // ç›‘å¬å±å¹•å…±äº«ç»“æŸäº‹ä»¶
        if (getStreamFunction === getScreenStream) {
          newStream.getVideoTracks()[0].addEventListener('ended', () => {
            console.log('å±å¹•å…±äº«å·²ç»“æŸï¼Œåˆ‡æ¢å›æ‘„åƒå¤´');
            replaceMediaStream(getCameraStream);
          });
        }

      } catch (error) {
        console.error('æ›¿æ¢åª’ä½“æµå¤±è´¥:', error);
      }
    }

    // åˆå§‹åŒ–WebRTCè¿æ¥
    function initializeWebRTC(stream) {
      currentStream = stream;
      
      // 2. åˆ›å»º WebRTC çš„ RTCPeerConnection å®ä¾‹ 
      // RTCPeerConnection æ˜¯ WebRTC çš„æ ¸å¿ƒæ¥å£ï¼Œç”¨äºå»ºç«‹ç‚¹å¯¹ç‚¹è¿æ¥
      // è´Ÿè´£å¤„ç†éŸ³è§†é¢‘æµçš„ä¼ è¾“ã€ICE åå•†ç­‰
      peer_connection = new RTCPeerConnection(
        {
          iceServers: [
            // **ä½ çš„ STUN æœåŠ¡å™¨é…ç½®**
            {
                urls: 'stun:117.72.204.201:3478'
            },
            // **ä½ çš„ TURN æœåŠ¡å™¨é…ç½® - TCP**
            {
                urls: 'turn:117.72.204.201:3478?transport=tcp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **ä½ çš„ TURN æœåŠ¡å™¨é…ç½® - UDP**
            {
                urls: 'turn:117.72.204.201:3478?transport=udp',
                username: 'matrix',
                credential: 'sual116y'
            },
            // **Google çš„å…¬å…± STUN æœåŠ¡å™¨ä½œä¸ºå¤‡ç”¨**
            {
                urls: 'stun:stun.l.google.com:19302'
            },
            // **Cloudflare STUN æœåŠ¡å™¨ä½œä¸ºå¤‡ç”¨**
            {
                urls: 'stun:stun.cloudflare.com:3478'
            }
          ],
          // æ ¹æ® forceRelay æ ‡å¿—å†³å®šæ˜¯å¦å¼ºåˆ¶ä½¿ç”¨ TURN
          iceTransportPolicy: forceRelay ? 'relay' : 'all'
        }
      )

      // 3. ç›‘å¬è¿œç«¯ track äº‹ä»¶ï¼ˆæ¥æ”¶åˆ°è¿œç«¯åª’ä½“æµæ—¶è§¦å‘ï¼‰
      peer_connection.ontrack = function (event) {
        // åªå¤„ç†è§†é¢‘è½¨é“ï¼Œå¿½ç•¥éŸ³é¢‘
        console.log('ontrack', event)
        if (event.track.kind === 'audio') {
          return
        }

        // åˆ›å»º video å…ƒç´ ç”¨äºæ’­æ”¾è¿œç«¯è§†é¢‘
        let el = document.createElement(event.track.kind)
        el.srcObject = event.streams[0]
        el.autoplay = true
        el.controls = true
        document.getElementById('remoteVideos').appendChild(el)

        // è¿œç«¯ track é™éŸ³æ—¶å°è¯•æ’­æ”¾ï¼ˆå…¼å®¹éƒ¨åˆ†æµè§ˆå™¨ç­–ç•¥ï¼‰
        event.track.onmute = function(event) {
          el.play()
        }

        // è¿œç«¯æµç§»é™¤ track æ—¶ï¼Œç§»é™¤ video å…ƒç´ 
        event.streams[0].onremovetrack = ({track}) => {
          if (el.parentNode) {
            el.parentNode.removeChild(el)
          }
        }
      }

      // 4. æ˜¾ç¤ºæœ¬åœ°è§†é¢‘æµ
      document.getElementById('localVideo').srcObject = stream
      // 5. å°†æœ¬åœ°éŸ³è§†é¢‘è½¨é“æ·»åŠ åˆ° RTCPeerConnection
      stream.getTracks().forEach(track => peer_connection.addTrack(track, stream))

      // 6. å»ºç«‹ WebSocket è¿æ¥åˆ°åç«¯ä¿¡ä»¤æœåŠ¡å™¨
      ws = new WebSocket("wss://meteor.matrix-net.tech/websocket")
      //ws = new WebSocket("ws://117.72.204.201:8080/websocket")

      // 7. ç›‘å¬ ICE candidate äº‹ä»¶ï¼Œå°†æœ¬åœ° candidate å‘é€ç»™åç«¯
      peer_connection.onicecandidate = e => {
        if (!e.candidate) {
          console.log('ICE gathering complete')
          return
        }
        // è®°å½• ICE candidate ç±»å‹ä»¥ä¾¿è°ƒè¯•
        console.log('ICE Candidate:', {
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidate: e.candidate.candidate
        })
        // å‘é€ candidate æ¶ˆæ¯ï¼Œdata å­—æ®µä¸ºå­—ç¬¦ä¸²åŒ–çš„ candidate å¯¹è±¡
        ws.send(JSON.stringify({event: 'candidate', data: JSON.stringify(e.candidate)}))
      }

      // ç›‘å¬ ICE è¿æ¥çŠ¶æ€å˜åŒ–
      peer_connection.oniceconnectionstatechange = () => {
        console.log('ICE Connection State:', peer_connection.iceConnectionState)
        const logDiv = document.getElementById('logs')
        logDiv.innerHTML += `<p>ICE è¿æ¥çŠ¶æ€: ${peer_connection.iceConnectionState}</p>`
        
        if (peer_connection.iceConnectionState === 'failed') {
          logDiv.innerHTML += '<p style="color: red;">ICE è¿æ¥å¤±è´¥ï¼å¯èƒ½çš„åŸå› ï¼š1. TURNæœåŠ¡å™¨ä¸å¯ç”¨ 2. ç½‘ç»œé˜²ç«å¢™é˜»å¡ 3. NATç±»å‹ä¸å…¼å®¹</p>'
        } else if (peer_connection.iceConnectionState === 'connected') {
          logDiv.innerHTML += '<p style="color: green;">ICE è¿æ¥æˆåŠŸï¼</p>'
        }
      }

      // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
      peer_connection.onconnectionstatechange = () => {
        console.log('Connection State:', peer_connection.connectionState)
        const logDiv = document.getElementById('logs')
        logDiv.innerHTML += `<p>è¿æ¥çŠ¶æ€: ${peer_connection.connectionState}</p>`
      }

      // 8. WebSocket å…³é—­æ—¶å¼¹çª—æç¤º
      ws.onclose = function(evt) {
        window.alert("Websocket has closed")
      }

      // 9. WebSocket æ”¶åˆ°æ¶ˆæ¯æ—¶çš„å¤„ç†é€»è¾‘
      ws.onmessage = function(evt) {
        // è§£ææ”¶åˆ°çš„ JSON æ¶ˆæ¯
        let msg = JSON.parse(evt.data)
        // è¾“å‡ºæ—¥å¿—åˆ°é¡µé¢
        console.log('ws message', msg)
        if (!msg) {
          return console.log('failed to parse msg')
        }

        // æ ¹æ® event å­—æ®µç±»å‹åˆ†æ”¯å¤„ç†
        switch (msg.event) {
          case 'paired':
            // æ”¶åˆ° 'paired' äº‹ä»¶ï¼Œæ ¹æ® data åˆ¤æ–­æ˜¯å¦ä¸ºå‘èµ·æ–¹
            // data ä¸º "true" è¡¨ç¤ºæ˜¯å‘èµ·æ–¹ï¼Œéœ€è¦åˆ›å»ºå¹¶å‘é€ offer
            if (msg.data === "true") {
              console.log("I am the initiator, creating offer...")
              peer_connection.createOffer().then(offer => {
                peer_connection.setLocalDescription(offer)
                ws.send(JSON.stringify({event: 'offer', data: JSON.stringify(offer)}))
              })
            } else {
              console.log("I am the receiver, waiting for offer...")
            }
            return

          case 'offer':
            // æ”¶åˆ°æœåŠ¡å™¨å‘æ¥çš„ offerï¼Œè§£æåè®¾ç½®ä¸ºè¿œç«¯æè¿°
            let offer = JSON.parse(msg.data)
            if (!offer) {
              return console.log('failed to parse offer')
            }
            console.log("Received offer, creating answer...")
            peer_connection.setRemoteDescription(offer)
            // åˆ›å»º answer å¹¶å‘é€å›æœåŠ¡å™¨
            peer_connection.createAnswer().then(answer => {
              peer_connection.setLocalDescription(answer)
              ws.send(JSON.stringify({event: 'answer', data: JSON.stringify(answer)}))
            })
            return
          
          case 'answer':
            // æ”¶åˆ°æœåŠ¡å™¨è½¬å‘çš„ answerï¼Œè§£æåè®¾ç½®ä¸ºè¿œç«¯æè¿°
            let answer = JSON.parse(msg.data)
            if (!answer) {
              return console.log('failed to parse answer')
            }
            peer_connection.setRemoteDescription(answer)
            return

          case 'candidate':
            // æ”¶åˆ°æœåŠ¡å™¨è½¬å‘çš„ candidateï¼Œè§£æååŠ å…¥ RTCPeerConnection
            let candidate = JSON.parse(msg.data)
            console.log('æ”¶åˆ°è¿œç«¯ ICE Candidate:', {
              type: candidate.type,
              protocol: candidate.protocol,
              address: candidate.address,
              port: candidate.port
            })
            // å¦‚æœ candidate è§£æå¤±è´¥ï¼Œè¾“å‡ºæ—¥å¿—å¹¶è¿”å›
            if (!candidate) {
              return console.log('failed to parse candidate')
            }
            peer_connection.addIceCandidate(candidate).catch(err => {
              console.error('æ·»åŠ  ICE candidate å¤±è´¥:', err)
            })
        }
      }

      // 10. WebSocket å‘ç”Ÿé”™è¯¯æ—¶è¾“å‡ºæ—¥å¿—
      ws.onerror = function(evt) {
        console.log("ERROR: " + evt.data)
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    document.addEventListener('DOMContentLoaded', function() {
      // TURN æœåŠ¡å™¨æµ‹è¯•æŒ‰é’®
      document.getElementById('testTurnBtn').addEventListener('click', testTurnServer);

      // ç½‘ç»œè¯Šæ–­æŒ‰é’®
      document.getElementById('diagnosisBtn').addEventListener('click', runNetworkDiagnosis);

      // å¼ºåˆ¶ TURN æ¨¡å¼æŒ‰é’®
      document.getElementById('forceRelayBtn').addEventListener('click', function() {
        forceRelay = !forceRelay;
        this.textContent = forceRelay ? 'å–æ¶ˆå¼ºåˆ¶ TURN æ¨¡å¼' : 'å¼ºåˆ¶ä½¿ç”¨ TURN æ¨¡å¼';
        this.style.backgroundColor = forceRelay ? '#ff6b6b' : '';
        
        const logDiv = document.getElementById('logs');
        logDiv.innerHTML += `<p>æ¨¡å¼åˆ‡æ¢: ${forceRelay ? 'å¼ºåˆ¶ TURN æ¨¡å¼' : 'è‡ªåŠ¨æ¨¡å¼'}</p>`;
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œé‡æ–°åˆå§‹åŒ–
        if (peer_connection && currentStream) {
          peer_connection.close();
          initializeWebRTC(currentStream);
        }
      });

      // æ‘„åƒå¤´æŒ‰é’®äº‹ä»¶
      document.getElementById('cameraBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getCameraStream);
        } else {
          getCameraStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // å±å¹•å…±äº«æŒ‰é’®äº‹ä»¶
      document.getElementById('screenBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getScreenStream);
        } else {
          getScreenStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // é»˜è®¤ä½¿ç”¨æ‘„åƒå¤´
      getCameraStream().then(stream => {
        initializeWebRTC(stream);
      }).catch(console.error);
    });
  </script>
</html>
