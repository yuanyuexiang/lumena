<!DOCTYPE html>
<html>
  <!--
    SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
    SPDX-License-Identifier: MIT
  -->

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumena è§†é¢‘é€šè¯</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- æ·»åŠ  MQTT åº“ -->
    <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>ğŸ¥ Lumena è§†é¢‘é€šè¯</h1>
      
      <!-- æ·»åŠ æˆ¿é—´ç®¡ç†åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸ  æˆ¿é—´ç®¡ç†</h3>
        <div class="button-group">
          <input type="text" id="roomIdInput" placeholder="è¾“å…¥æˆ¿é—´IDæˆ–ç•™ç©ºè‡ªåŠ¨ç”Ÿæˆ" class="input-field">
          <button id="joinRoomBtn" class="btn success">åŠ å…¥æˆ¿é—´</button>
          <button id="shareRoomBtn" class="btn">åˆ†äº«æˆ¿é—´</button>
        </div>
        <div class="status-item">
          <span class="status-label">å½“å‰æˆ¿é—´:</span>
          <span class="status-value" id="currentRoom">æœªåŠ å…¥</span>
        </div>
        <div class="status-item">
          <span class="status-label">æˆ‘çš„ID:</span>
          <span class="status-value" id="myPeerId">-</span>
        </div>
      </div>
      
      <div class="grid-2">
        <div>
          <!-- ç°æœ‰çš„ç½‘ç»œè¯Šæ–­åŒºåŸŸ -->
          <div class="section">
            <h3>ğŸ”§ ç½‘ç»œè¯Šæ–­</h3>
            <div class="button-group">
              <button id="testTurnBtn" class="btn">æµ‹è¯• TURN æœåŠ¡å™¨</button>
              <button id="diagnosisBtn" class="btn">ç½‘ç»œè¯Šæ–­</button>
              <button id="priorityTestBtn" class="btn success">ğŸš€ ä¼˜å…ˆçº§è¿æ¥æµ‹è¯•</button>
              <button id="forceRelayBtn" class="btn">å¼ºåˆ¶ TURN æ¨¡å¼</button>
            </div>
            <div id="turnTestResult" class="result-box"></div>
            <div id="diagnosisResult" class="result-box"></div>
            <div id="priorityTestResult" class="result-box"></div>
          </div>

          <!-- åª’ä½“æºé€‰æ‹© -->
          <div class="section">
            <h3>ğŸ“¹ åª’ä½“æºé€‰æ‹©</h3>
            <div class="button-group">
              <button id="cameraBtn" class="btn success">ğŸ“· ä½¿ç”¨æ‘„åƒå¤´</button>
              <button id="screenBtn" class="btn">ğŸ–¥ï¸ å±å¹•å…±äº«</button>
            </div>
            <span id="currentSource" class="current-source">å½“å‰ï¼šæœªé€‰æ‹©</span>
          </div>

          <!-- è¿æ¥çŠ¶æ€ -->
          <div class="section">
            <h3>ğŸ“¡ è¿æ¥çŠ¶æ€</h3>
            <div class="status-box">
              <div class="status-item">
                <span class="status-label">è¿æ¥æ–¹å¼:</span>
                <span class="status-value">
                  <span class="connection-indicator disconnected"></span>
                  <span id="connectionType">æœªè¿æ¥</span>
                </span>
              </div>
              <div class="status-item">
                <span class="status-label">æœ¬åœ°å€™é€‰:</span>
                <span class="status-value" id="localCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">è¿œç¨‹å€™é€‰:</span>
                <span class="status-value" id="remoteCandidate">-</span>
              </div>
              <div class="status-item">
                <span class="status-label">ç½‘ç»œå»¶è¿Ÿ:</span>
                <span class="status-value" id="networkDelay">-</span>
              </div>
            </div>
          </div>
        </div>

        <div>
          <!-- è§†é¢‘åŒºåŸŸ -->
          <div class="section">
            <h3>ğŸ¬ è§†é¢‘é¢„è§ˆ</h3>
            <div class="video-container">
              <div class="video-box">
                <h4>æœ¬åœ°è§†é¢‘</h4>
                <video id="localVideo" width="320" height="240" autoplay muted></video>
              </div>
              <div class="video-box">
                <h4>è¿œç¨‹è§†é¢‘</h4>
                <div id="remoteVideos">
                  <video id="remoteVideo" width="320" height="240" autoplay></video>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- æ—¥å¿—åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logs" class="logs"></div>
      </div>
    </div>
  </body>

  <script>
    let peer_connection;
    let ws;
    let currentStream;
    let forceRelay = false; // æ˜¯å¦å¼ºåˆ¶ä½¿ç”¨ TURN
    let connectionStatsInterval; // è¿æ¥çŠ¶æ€æ£€æµ‹å®šæ—¶å™¨
    let optimalConnectionMode = 'auto'; // æœ€ä¼˜è¿æ¥æ¨¡å¼ï¼š'lan', 'nat', 'relay', 'auto'

    // æ›´æ–° MQTT è¿æ¥é…ç½®
    let mqttClient;
    let roomId = 'room-' + Math.random().toString(36).substr(2, 9);
    let localPeerId = 'peer-' + Math.random().toString(36).substr(2, 9);

    // åˆå§‹åŒ– MQTT è¿æ¥
    function initializeMQTT() {
      // ä½¿ç”¨ä½ éƒ¨ç½²çš„ EMQX æœåŠ¡å™¨
      const brokerUrl = 'wss://meteor.matrix-net.tech/mqtt';
      
      console.log('Connecting to EMQX MQTT broker:', brokerUrl);
      
      mqttClient = mqtt.connect(brokerUrl, {
        clientId: localPeerId,
        clean: true,
        connectTimeout: 4000,
        username: 'matrix',      // ä½¿ç”¨ä½ çš„ EMQX ç”¨æˆ·å
        password: 'sual116y',    // ä½¿ç”¨ä½ çš„ EMQX å¯†ç 
        reconnectPeriod: 1000,
        protocolVersion: 4,      // MQTT 3.1.1
        keepalive: 60,
      });

      mqttClient.on('connect', function () {
        console.log('âœ… EMQX MQTT Connected successfully');
        
        // æ›´æ–°UIæ˜¾ç¤º
        document.getElementById('currentRoom').textContent = roomId;
        
        // è®¢é˜…æˆ¿é—´ä¸»é¢˜
        mqttClient.subscribe(`webrtc/${roomId}/+/+`, function (err) {
          if (!err) {
            console.log(`ğŸ“¡ Subscribed to room: ${roomId}`);
            
            // å‘é€åŠ å…¥æˆ¿é—´æ¶ˆæ¯
            mqttClient.publish(`webrtc/${roomId}/${localPeerId}/join`, JSON.stringify({
              type: 'join',
              peerId: localPeerId,
              timestamp: Date.now()
            }));
            
            // æ›´æ–°æ—¥å¿—
            const logDiv = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ‰ å·²è¿æ¥åˆ°EMQXæœåŠ¡å™¨å¹¶åŠ å…¥æˆ¿é—´: ${roomId}</p>`;
            logDiv.scrollTop = logDiv.scrollHeight;
          } else {
            console.error('âŒ Failed to subscribe to room:', err);
          }
        });
      });

      mqttClient.on('message', function (topic, message) {
        const topicParts = topic.split('/');
        const remotePeerId = topicParts[2];
        const messageType = topicParts[3];
        
        // å¿½ç•¥è‡ªå·±å‘é€çš„æ¶ˆæ¯
        if (remotePeerId === localPeerId) return;
        
        try {
          const data = JSON.parse(message.toString());
          console.log('ğŸ“¥ MQTT message received:', { topic, messageType, data });
          
          // æ›´æ–°æ—¥å¿—
          const logDiv = document.getElementById('logs');
          const timestamp = new Date().toLocaleTimeString();
          logDiv.innerHTML += `<p style="color: #74c0fc;">[${timestamp}] ğŸ“¨ æ”¶åˆ°${messageType}æ¶ˆæ¯æ¥è‡ª: ${remotePeerId}</p>`;
          logDiv.scrollTop = logDiv.scrollHeight;
          
          handleSignalingMessage(messageType, data, remotePeerId);
        } catch (error) {
          console.error('âŒ Error parsing MQTT message:', error);
        }
      });

      mqttClient.on('error', function (error) {
        console.error('âŒ EMQX MQTT Error:', error);
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ MQTTè¿æ¥å¤±è´¥: ${error.message}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });

      mqttClient.on('disconnect', function () {
        console.log('ğŸ”Œ EMQX MQTT Disconnected');
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p style="color: #ffd43b;">[${timestamp}] ğŸ”Œ MQTTè¿æ¥æ–­å¼€</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });

      mqttClient.on('reconnect', function () {
        console.log('ğŸ”„ EMQX MQTT Reconnecting...');
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p style="color: #ffd43b;">[${timestamp}] ğŸ”„ æ­£åœ¨é‡è¿MQTTæœåŠ¡å™¨...</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });
    }

    // ä¼˜å…ˆçº§è¿æ¥æµ‹è¯•
    async function runPriorityConnectionTest() {
      const resultDiv = document.getElementById('priorityTestResult');
      resultDiv.innerHTML = '<p>ğŸ” æ­£åœ¨è¿›è¡Œä¼˜å…ˆçº§è¿æ¥æµ‹è¯•...</p>';
      
      const testResults = {
        lan: { available: false, delay: null, quality: 0 },
        nat: { available: false, delay: null, quality: 0 },
        relay: { available: false, delay: null, quality: 0 }
      };

      try {
        // 1. æµ‹è¯•å±€åŸŸç½‘ç›´è¿ (Host candidates only)
        resultDiv.innerHTML += '<p>ğŸ“ 1/3 æµ‹è¯•å±€åŸŸç½‘ç›´è¿...</p>';
        testResults.lan = await testConnectionMode('host-only');
        
        // 2. æµ‹è¯•NATç©¿é€ (STUN)
        resultDiv.innerHTML += '<p>ğŸŒ 2/3 æµ‹è¯•NATç©¿é€...</p>';
        testResults.nat = await testConnectionMode('nat-traversal');
        
        // 3. æµ‹è¯•TURNä¸­ç»§
        resultDiv.innerHTML += '<p>ğŸ”„ 3/3 æµ‹è¯•TURNä¸­ç»§...</p>';
        testResults.relay = await testConnectionMode('relay-only');
        
        // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Šå’Œå»ºè®®
        const report = generatePriorityTestReport(testResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML += `<p style="color: red;">æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
      }
    }

    // æµ‹è¯•ç‰¹å®šè¿æ¥æ¨¡å¼
    async function testConnectionMode(mode) {
      return new Promise(async (resolve) => {
        let iceServers = [];
        let iceTransportPolicy = 'all';
        
        // æ ¹æ®æ¨¡å¼é…ç½®ICEæœåŠ¡å™¨
        switch (mode) {
          case 'host-only':
            // åªä½¿ç”¨æœ¬åœ°å€™é€‰ï¼Œæ¨¡æ‹Ÿå±€åŸŸç½‘ç¯å¢ƒ
            iceServers = [];
            iceTransportPolicy = 'all';
            break;
            
          case 'nat-traversal':
            // ä½¿ç”¨STUNæœåŠ¡å™¨è¿›è¡ŒNATç©¿é€
            iceServers = [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:coturn.meteor.matrix-net.tech:3478' }
            ];
            iceTransportPolicy = 'all';
            break;
            
          case 'relay-only':
            // å¼ºåˆ¶ä½¿ç”¨TURNä¸­ç»§
            iceServers = [
              {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
                username: 'matrix',
                credential: 'sual116y'
              },
              {
                urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
                username: 'matrix',
                credential: 'sual116y'
              }
            ];
            iceTransportPolicy = 'relay';
            break;
        }

        const testPC = new RTCPeerConnection({
          iceServers,
          iceTransportPolicy
        });

        const result = {
          available: false,
          delay: null,
          quality: 0,
          candidateTypes: []
        };

        let startTime = Date.now();
        let candidatesFound = false;

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            candidatesFound = true;
            result.candidateTypes.push(event.candidate.type);
            
            // è®¡ç®—ICEå€™é€‰æ”¶é›†å»¶è¿Ÿ
            if (!result.delay) {
              result.delay = Date.now() - startTime;
            }
            
            // æ ¹æ®å€™é€‰ç±»å‹åˆ¤æ–­æ˜¯å¦å¯ç”¨
            switch (mode) {
              case 'host-only':
                if (event.candidate.type === 'host') {
                  result.available = true;
                  result.quality = 100; // å±€åŸŸç½‘è´¨é‡æœ€é«˜
                }
                break;
              case 'nat-traversal':
                if (event.candidate.type === 'srflx') {
                  result.available = true;
                  result.quality = 75; // NATç©¿é€è´¨é‡ä¸­ç­‰
                }
                break;
              case 'relay-only':
                if (event.candidate.type === 'relay') {
                  result.available = true;
                  result.quality = 50; // ä¸­ç»§è´¨é‡è¾ƒä½ä½†ç¨³å®š
                }
                break;
            }
          } else {
            // ICEæ”¶é›†å®Œæˆ
            testPC.close();
            resolve(result);
          }
        };

        // åˆ›å»ºæ•°æ®é€šé“è§¦å‘ICEæ”¶é›†
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // è®¾ç½®è¶…æ—¶
        setTimeout(() => {
          if (!candidatesFound && !result.available) {
            result.available = false;
            result.delay = Date.now() - startTime;
          }
          testPC.close();
          resolve(result);
        }, 5000);
      });
    }

    // ç”Ÿæˆä¼˜å…ˆçº§æµ‹è¯•æŠ¥å‘Š
    function generatePriorityTestReport(testResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 15px; margin: 10px 0; border-radius: 10px;">';
      report += '<h4>ğŸ¯ ä¼˜å…ˆçº§è¿æ¥æµ‹è¯•æŠ¥å‘Š</h4>';
      
      // æŒ‰ä¼˜å…ˆçº§æ’åºçš„è¿æ¥æ–¹å¼
      const connectionMethods = [
        { key: 'lan', name: 'ğŸ  å±€åŸŸç½‘ç›´è¿', priority: 1 },
        { key: 'nat', name: 'ğŸŒ NATç©¿é€', priority: 2 },
        { key: 'relay', name: 'ğŸ”„ TURNä¸­ç»§', priority: 3 }
      ];
      
      report += '<table style="width: 100%; border-collapse: collapse; margin: 15px 0;">';
      report += '<tr style="background: #f8f9fa;"><th style="padding: 10px; border: 1px solid #dee2e6;">ä¼˜å…ˆçº§</th><th style="padding: 10px; border: 1px solid #dee2e6;">è¿æ¥æ–¹å¼</th><th style="padding: 10px; border: 1px solid #dee2e6;">çŠ¶æ€</th><th style="padding: 10px; border: 1px solid #dee2e6;">å»¶è¿Ÿ</th><th style="padding: 10px; border: 1px solid #dee2e6;">è´¨é‡è¯„åˆ†</th></tr>';
      
      let recommendedMode = null;
      let bestQuality = 0;
      
      connectionMethods.forEach(method => {
        const result = testResults[method.key];
        const status = result.available ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨';
        const delay = result.delay ? `${result.delay}ms` : '-';
        const quality = result.available ? `${result.quality}/100` : '-';
        
        const rowColor = result.available ? '#d4edda' : '#f8d7da';
        report += `<tr style="background: ${rowColor};"><td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${method.priority}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${method.name}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${status}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${delay}</td><td style="padding: 8px; border: 1px solid #dee2e6;">${quality}</td></tr>`;
        
        // æ‰¾åˆ°æœ€ä¼˜è¿æ¥æ–¹å¼ï¼ˆæŒ‰ä¼˜å…ˆçº§å’Œè´¨é‡ï¼‰
        if (result.available && (!recommendedMode || method.priority < connectionMethods.find(m => m.key === recommendedMode).priority)) {
          recommendedMode = method.key;
          bestQuality = result.quality;
        }
      });
      
      report += '</table>';
      
      // æ¨èæ–¹æ¡ˆ
      if (recommendedMode) {
        const recommendedMethod = connectionMethods.find(m => m.key === recommendedMode);
        optimalConnectionMode = recommendedMode; // ä¿å­˜æœ€ä¼˜æ¨¡å¼
        
        report += `<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
        report += `<h5 style="color: #0c5460; margin: 0 0 10px 0;">ğŸ’¡ æ¨èè¿æ¥æ–¹å¼</h5>`;
        report += `<p style="margin: 0;"><strong>${recommendedMethod.name}</strong> - è´¨é‡è¯„åˆ†: ${bestQuality}/100</p>`;
        report += `<button id="applyOptimalMode" class="btn success" style="margin-top: 10px;">ğŸš€ åº”ç”¨æœ€ä¼˜é…ç½®</button>`;
        report += `</div>`;
      } else {
        report += `<div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">`;
        report += `<h5 style="color: #721c24; margin: 0 0 10px 0;">âš ï¸ è¿æ¥é—®é¢˜</h5>`;
        report += `<p style="margin: 0;">æ‰€æœ‰è¿æ¥æ–¹å¼å‡ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œé…ç½®å’ŒTURNæœåŠ¡å™¨çŠ¶æ€ã€‚</p>`;
        report += `</div>`;
      }
      
      report += '</div>';
      return report;
    }

    // åº”ç”¨æœ€ä¼˜è¿æ¥æ¨¡å¼
    function applyOptimalConnectionMode() {
      if (!optimalConnectionMode || optimalConnectionMode === 'auto') return;
      
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      
      switch (optimalConnectionMode) {
        case 'lan':
          // åº”ç”¨å±€åŸŸç½‘ç›´è¿é…ç½®
          forceRelay = false;
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ  å·²åˆ‡æ¢åˆ°å±€åŸŸç½‘ç›´è¿æ¨¡å¼</p>`;
          break;
        case 'nat':
          // åº”ç”¨NATç©¿é€é…ç½®
          forceRelay = false;
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸŒ å·²åˆ‡æ¢åˆ°NATç©¿é€æ¨¡å¼</p>`;
          break;
        case 'relay':
          // åº”ç”¨TURNä¸­ç»§é…ç½®
          forceRelay = true;
          document.getElementById('forceRelayBtn').textContent = 'ğŸ”„ å–æ¶ˆå¼ºåˆ¶ TURN';
          document.getElementById('forceRelayBtn').className = 'btn danger';
          logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ”„ å·²åˆ‡æ¢åˆ°TURNä¸­ç»§æ¨¡å¼</p>`;
          break;
      }
      
      logDiv.scrollTop = logDiv.scrollHeight;
      
      // å¦‚æœå·²æœ‰è¿æ¥ï¼Œé‡æ–°åˆå§‹åŒ–
      if (peer_connection && currentStream) {
        stopConnectionMonitoring();
        peer_connection.close();
        initializeWebRTC(currentStream);
      }
    }

    // æ£€æµ‹è¿æ¥ç±»å‹å’ŒçŠ¶æ€
    async function checkConnectionType() {
      if (!peer_connection) return;

      try {
        const stats = await peer_connection.getStats();
        let localCandidate = null;
        let remoteCandidate = null;
        let connectionType = 'æœªçŸ¥';
        let rtt = null;

        stats.forEach(report => {
          // è·å–æœ¬åœ°å€™é€‰ä¿¡æ¯
          if (report.type === 'local-candidate') {
            localCandidate = report;
          }
          // è·å–è¿œç¨‹å€™é€‰ä¿¡æ¯
          if (report.type === 'remote-candidate') {
            remoteCandidate = report;
          }
          // è·å–å€™é€‰å¯¹ä¿¡æ¯
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            // æ ¹æ®å€™é€‰ç±»å‹åˆ¤æ–­è¿æ¥æ–¹å¼
            const localType = getLocalCandidateType(report.localCandidateId, stats);
            const remoteType = getRemoteCandidateType(report.remoteCandidateId, stats);
            
            connectionType = determineConnectionType(localType, remoteType);
            
            // è·å–ç½‘ç»œå»¶è¿Ÿ
            if (report.currentRoundTripTime) {
              rtt = Math.round(report.currentRoundTripTime * 1000); // è½¬æ¢ä¸ºæ¯«ç§’
            }
          }
        });

        // æ›´æ–°UIæ˜¾ç¤º
        updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt);

      } catch (error) {
        console.error('è·å–è¿æ¥ç»Ÿè®¡å¤±è´¥:', error);
      }
    }

    // è·å–æœ¬åœ°å€™é€‰ç±»å‹
    function getLocalCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'local-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // è·å–è¿œç¨‹å€™é€‰ç±»å‹
    function getRemoteCandidateType(candidateId, stats) {
      for (let [id, report] of stats) {
        if (report.id === candidateId && report.type === 'remote-candidate') {
          return report.candidateType;
        }
      }
      return 'unknown';
    }

    // åˆ¤æ–­è¿æ¥ç±»å‹
    function determineConnectionType(localType, remoteType) {
      console.log('Local candidate type:', localType, 'Remote candidate type:', remoteType);
      
      // å¦‚æœä»»ä¸€æ–¹ä½¿ç”¨ relayï¼Œåˆ™æ˜¯ TURN è½¬å‘
      if (localType === 'relay' || remoteType === 'relay') {
        return 'ğŸ”„ TURN è½¬å‘';
      }
      
      // å¦‚æœéƒ½æ˜¯ hostï¼Œåˆ™æ˜¯ç›´æ¥è¿æ¥ï¼ˆå±€åŸŸç½‘ï¼‰
      if (localType === 'host' && remoteType === 'host') {
        return 'ğŸ  å±€åŸŸç½‘ç›´è¿';
      }
      
      // å¦‚æœæœ‰ srflxï¼ˆæœåŠ¡å™¨åå°„ï¼‰ï¼Œåˆ™æ˜¯é€šè¿‡ NAT
      if (localType === 'srflx' || remoteType === 'srflx') {
        return 'ğŸŒ NAT ç©¿é€';
      }
      
      // å¦‚æœæœ‰ prflxï¼ˆå¯¹ç­‰åå°„ï¼‰ï¼Œä¹Ÿæ˜¯ NAT ç©¿é€çš„ä¸€ç§
      if (localType === 'prflx' || remoteType === 'prflx') {
        return 'ğŸŒ NAT ç©¿é€ (å¯¹ç­‰åå°„)';
      }
      
      return `â“ æœªçŸ¥ (${localType}/${remoteType})`;
    }

    // æ›´æ–°è¿æ¥ä¿¡æ¯æ˜¾ç¤º
    function updateConnectionInfo(connectionType, localCandidate, remoteCandidate, rtt) {
      document.getElementById('connectionType').textContent = connectionType;
      
      // æ›´æ–°è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator';
      if (connectionType.includes('æœªè¿æ¥')) {
        indicator.classList.add('disconnected');
      } else if (connectionType.includes('è¿æ¥ä¸­')) {
        indicator.classList.add('connecting');
      } else {
        indicator.classList.add('connected');
      }
      
      // æ›´æ–°æœ¬åœ°å€™é€‰ä¿¡æ¯
      if (localCandidate) {
        const localInfo = `${localCandidate.candidateType} (${localCandidate.protocol}) ${localCandidate.address}:${localCandidate.port}`;
        document.getElementById('localCandidate').textContent = localInfo;
      }
      
      // æ›´æ–°è¿œç¨‹å€™é€‰ä¿¡æ¯
      if (remoteCandidate) {
        const remoteInfo = `${remoteCandidate.candidateType} (${remoteCandidate.protocol}) ${remoteCandidate.address}:${remoteCandidate.port}`;
        document.getElementById('remoteCandidate').textContent = remoteInfo;
      }
      
      // æ›´æ–°ç½‘ç»œå»¶è¿Ÿ
      if (rtt !== null) {
        document.getElementById('networkDelay').textContent = `${rtt} ms`;
        
        // æ ¹æ®å»¶è¿Ÿæ·»åŠ é¢œè‰²æŒ‡ç¤º
        const delayElement = document.getElementById('networkDelay');
        if (rtt < 50) {
          delayElement.style.color = '#51cf66';
        } else if (rtt < 150) {
          delayElement.style.color = '#ffd43b';
        } else {
          delayElement.style.color = '#ff6b6b';
        }
      }
    }

    // å¼€å§‹è¿æ¥çŠ¶æ€ç›‘æ§
    function startConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
      }
      
      connectionStatsInterval = setInterval(() => {
        checkConnectionType();
      }, 2000); // æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡
    }

    // åœæ­¢è¿æ¥çŠ¶æ€ç›‘æ§
    function stopConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
        connectionStatsInterval = null;
      }
      
      // é‡ç½®æ˜¾ç¤º
      document.getElementById('connectionType').textContent = 'æœªè¿æ¥';
      document.getElementById('localCandidate').textContent = '-';
      document.getElementById('remoteCandidate').textContent = '-';
      document.getElementById('networkDelay').textContent = '-';
      document.getElementById('networkDelay').style.color = '';
      
      // æ›´æ–°è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
      const indicator = document.querySelector('.connection-indicator');
      indicator.className = 'connection-indicator disconnected';
    }

    // ç½‘ç»œè¯Šæ–­åŠŸèƒ½
    async function runNetworkDiagnosis() {
      const resultDiv = document.getElementById('diagnosisResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨è¿›è¡Œç½‘ç»œè¯Šæ–­...</p>';
      
      try {
        // 1. æ£€æµ‹æœ¬åœ°ç½‘ç»œä¿¡æ¯
        const localInfo = await getLocalNetworkInfo();
        
        // 2. æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidate
        const iceResults = await testICECandidates();
        
        // 3. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
        const report = generateDiagnosisReport(localInfo, iceResults);
        resultDiv.innerHTML = report;
        
      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">è¯Šæ–­å¤±è´¥: ${error.message}</p>`;
      }
    }

    // è·å–æœ¬åœ°ç½‘ç»œä¿¡æ¯
    async function getLocalNetworkInfo() {
      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection();
        const info = {
          localIPs: [],
          networkType: 'unknown'
        };

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const candidate = event.candidate.candidate;
            const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
            if (ipMatch && !info.localIPs.includes(ipMatch[1])) {
              info.localIPs.push(ipMatch[1]);
            }
          } else {
            // ICE æ”¶é›†å®Œæˆ
            testPC.close();
            resolve(info);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
          testPC.close();
          resolve(info);
        }, 3000);
      });
    }

    // æµ‹è¯•ä¸åŒç±»å‹çš„ ICE candidates
    async function testICECandidates() {
      const results = {
        host: false,
        srflx: false,
        relay: false
      };

      return new Promise((resolve) => {
        const testPC = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ]
        });

        testPC.onicecandidate = (event) => {
          if (event.candidate) {
            const type = event.candidate.type;
            if (type === 'host') results.host = true;
            if (type === 'srflx') results.srflx = true;
            if (type === 'relay') results.relay = true;
          } else {
            testPC.close();
            resolve(results);
          }
        };

        testPC.createDataChannel('test');
        testPC.createOffer().then(offer => {
          testPC.setLocalDescription(offer);
        });

        setTimeout(() => {
          testPC.close();
          resolve(results);
        }, 5000);
      });
    }

    // ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
    function generateDiagnosisReport(localInfo, iceResults) {
      let report = '<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0;">';
      report += '<h4>ğŸ“Š ç½‘ç»œè¯Šæ–­æŠ¥å‘Š</h4>';
      
      // æœ¬åœ° IP ä¿¡æ¯
      report += '<p><strong>æœ¬åœ° IP åœ°å€:</strong></p><ul>';
      localInfo.localIPs.forEach(ip => {
        const isPrivate = isPrivateIP(ip);
        report += `<li>${ip} ${isPrivate ? '(å†…ç½‘)' : '(å…¬ç½‘)'}</li>`;
      });
      report += '</ul>';

      // ICE candidate æ”¯æŒæƒ…å†µ
      report += '<p><strong>ICE Candidate æ”¯æŒ:</strong></p><ul>';
      report += `<li>Host (æœ¬åœ°): ${iceResults.host ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Server Reflexive (STUN): ${iceResults.srflx ? 'âœ“' : 'âœ—'}</li>`;
      report += `<li>Relay (TURN): ${iceResults.relay ? 'âœ“' : 'âœ—'}</li>`;
      report += '</ul>';

      // NAT ç±»å‹æ¨æ–­
      let natType = 'Unknown';
      if (iceResults.host && iceResults.srflx && iceResults.relay) {
        natType = 'Open Internet / Full Cone NAT';
      } else if (iceResults.srflx && iceResults.relay) {
        natType = 'Symmetric NAT (éœ€è¦ TURN)';
      } else if (iceResults.host && iceResults.srflx) {
        natType = 'Restricted Cone NAT';
      } else if (iceResults.relay) {
        natType = 'Strict NAT (ä»… TURN å¯ç”¨)';
      }

      report += `<p><strong>æ¨æ–­ NAT ç±»å‹:</strong> ${natType}</p>`;

      // å»ºè®®
      report += '<p><strong>è·¨ç½‘ç»œé€šä¿¡å»ºè®®:</strong></p><ul>';
      if (iceResults.relay) {
        report += '<li style="color: green;">âœ“ TURN æœåŠ¡å™¨å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡åº”è¯¥æ­£å¸¸</li>';
      } else {
        report += '<li style="color: red;">âœ— TURN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œè·¨ç½‘ç»œé€šä¿¡å¯èƒ½å¤±è´¥</li>';
      }
      
      if (!iceResults.srflx) {
        report += '<li style="color: orange;">âš  STUN æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œå¯èƒ½å½±å“ NAT ç©¿é€</li>';
      }

      report += '</ul></div>';
      return report;
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºå†…ç½‘ IP
    function isPrivateIP(ip) {
      const parts = ip.split('.').map(Number);
      return (
        (parts[0] === 10) ||
        (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === 192 && parts[1] === 168) ||
        (parts[0] === 127)
      );
    }

    // æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§
    async function testTurnServer() {
      const resultDiv = document.getElementById('turnTestResult');
      resultDiv.innerHTML = '<p>æ­£åœ¨æµ‹è¯• TURN æœåŠ¡å™¨è¿é€šæ€§...</p>';
      
      try {
        const testPC = new RTCPeerConnection({
          iceServers: [
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
              username: 'matrix',
              credential: 'sual116y'
            },
            {
              urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
              username: 'matrix',
              credential: 'sual116y'
            }
          ],
          iceTransportPolicy: 'relay' // å¼ºåˆ¶åªä½¿ç”¨ TURN
        });

        let turnCandidateFound = false;
        
        testPC.onicecandidate = (event) => {
          if (event.candidate && event.candidate.type === 'relay') {
            turnCandidateFound = true;
            resultDiv.innerHTML = '<p style="color: green;">âœ“ TURN æœåŠ¡å™¨è¿æ¥æˆåŠŸï¼</p>';
            console.log('TURN candidate found:', event.candidate);
          }
        };

        // åˆ›å»ºæ•°æ®é€šé“è§¦å‘ ICE æ”¶é›†
        testPC.createDataChannel('test');
        const offer = await testPC.createOffer();
        await testPC.setLocalDescription(offer);

        // ç­‰å¾… ICE æ”¶é›†å®Œæˆ
        setTimeout(() => {
          if (!turnCandidateFound) {
            resultDiv.innerHTML = '<p style="color: red;">âœ— TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br/>1. æœåŠ¡å™¨åœ°å€æ˜¯å¦æ­£ç¡®<br/>2. ç”¨æˆ·åå¯†ç æ˜¯å¦æ­£ç¡®<br/>3. ç«¯å£æ˜¯å¦è¢«é˜²ç«å¢™é˜»å¡<br/>4. TURN æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ</p>';
          }
          testPC.close();
        }, 5000);

      } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">æµ‹è¯•å¤±è´¥: ${error.message}</p>`;
        console.error('TURN test error:', error);
      }
    }

    // è·å–æ‘„åƒå¤´æµ
    async function getCameraStream() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šæ‘„åƒå¤´';
        return stream;
      } catch (error) {
        console.error('è·å–æ‘„åƒå¤´å¤±è´¥:', error);
        window.alert('è·å–æ‘„åƒå¤´å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // è·å–å±å¹•å…±äº«æµ
    async function getScreenStream() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        document.getElementById('currentSource').textContent = 'å½“å‰ï¼šå±å¹•å…±äº«';
        return stream;
      } catch (error) {
        console.error('è·å–å±å¹•å…±äº«å¤±è´¥:', error);
        window.alert('è·å–å±å¹•å…±äº«å¤±è´¥: ' + error.message);
        throw error;
      }
    }

    // æ›¿æ¢åª’ä½“æµ
    async function replaceMediaStream(getStreamFunction) {
      try {
        const newStream = await getStreamFunction();
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œæ›¿æ¢è½¨é“
        if (peer_connection && currentStream) {
          // ç§»é™¤æ—§çš„è½¨é“
          const senders = peer_connection.getSenders();
          for (const sender of senders) {
            if (sender.track) {
              peer_connection.removeTrack(sender);
            }
          }
          
          // æ·»åŠ æ–°çš„è½¨é“
          newStream.getTracks().forEach(track => {
            peer_connection.addTrack(track, newStream);
          });
        }

        // åœæ­¢æ—§æµ
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }

        // æ›´æ–°æœ¬åœ°è§†é¢‘æ˜¾ç¤º
        document.getElementById('localVideo').srcObject = newStream;
        currentStream = newStream;

        // ç›‘å¬å±å¹•å…±äº«ç»“æŸäº‹ä»¶
        if (getStreamFunction === getScreenStream) {
          newStream.getVideoTracks()[0].addEventListener('ended', () => {
            console.log('å±å¹•å…±äº«å·²ç»“æŸï¼Œåˆ‡æ¢å›æ‘„åƒå¤´');
            replaceMediaStream(getCameraStream);
          });
        }

      } catch (error) {
        console.error('æ›¿æ¢åª’ä½“æµå¤±è´¥:', error);
      }
    }

    // åˆå§‹åŒ–WebRTCè¿æ¥
    function initializeWebRTC(stream) {
      currentStream = stream;
      
      // ICE æœåŠ¡å™¨é…ç½®
      let iceServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:coturn.meteor.matrix-net.tech:3478' },
        {
          urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
          username: 'matrix',
          credential: 'sual116y'
        },
        {
          urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=udp',
          username: 'matrix',
          credential: 'sual116y'
        }
      ];

      let iceTransportPolicy = forceRelay ? 'relay' : 'all';

      // åˆ›å»º RTCPeerConnection
      peer_connection = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy
      });

      // æ·»åŠ æœ¬åœ°æµ
      stream.getTracks().forEach(track => {
        peer_connection.addTrack(track, stream);
      });

      // å¤„ç†è¿œç¨‹æµ
      peer_connection.ontrack = (event) => {
        console.log('ğŸ¥ Remote stream received');
        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.srcObject = event.streams[0];
        
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ¥ è¿œç¨‹è§†é¢‘æµå·²è¿æ¥</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      };

      // å¤„ç† ICE candidate
      peer_connection.onicecandidate = e => {
        if (!e.candidate) {
          console.log('â„ï¸ ICE gathering complete');
          return;
        }
        
        console.log('ğŸ¯ ICE Candidate:', {
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port
        });
        
        // é€šè¿‡ MQTT å‘é€ candidate
        sendSignalingMessage('candidate', e.candidate);
      };

      // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
      peer_connection.onconnectionstatechange = () => {
        console.log('ğŸ”— Connection state:', peer_connection.connectionState);
        
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        
        switch (peer_connection.connectionState) {
          case 'connected':
            logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ‰ P2Pè¿æ¥å·²å»ºç«‹ï¼</p>`;
            startConnectionMonitoring();
            break;
          case 'disconnected':
            logDiv.innerHTML += `<p style="color: #ffd43b;">[${timestamp}] ğŸ”Œ P2Pè¿æ¥å·²æ–­å¼€</p>`;
            break;
          case 'failed':
            logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ P2Pè¿æ¥å¤±è´¥</p>`;
            break;
        }
        logDiv.scrollTop = logDiv.scrollHeight;
      };

      // åˆå§‹åŒ– MQTT è¿æ¥
      if (!mqttClient) {
        initializeMQTT();
      }
    }

    // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
    function handleSignalingMessage(messageType, data, remotePeerId) {
      switch (messageType) {
        case 'join':
          console.log(`ğŸ‘‹ Peer ${remotePeerId} joined the room`);
          // å¦‚æœæ˜¯ååŠ å…¥çš„ç”¨æˆ·ï¼Œåˆ›å»º offer
          if (data.timestamp > getLocalJoinTime()) {
            createOffer(remotePeerId);
          }
          break;
          
        case 'offer':
          console.log("ğŸ“ Received offer from", remotePeerId);
          handleOffer(data, remotePeerId);
          break;
          
        case 'answer':
          console.log("âœ… Received answer from", remotePeerId);
          handleAnswer(data);
          break;
          
        case 'candidate':
          console.log("ğŸ¯ Received ICE candidate from", remotePeerId);
          handleIceCandidate(data);
          break;
      }
    }

    // å‘é€ä¿¡ä»¤æ¶ˆæ¯
    function sendSignalingMessage(messageType, data, targetPeerId = null) {
      const topic = `webrtc/${roomId}/${localPeerId}/${messageType}`;
      const message = JSON.stringify(data);
      
      mqttClient.publish(topic, message, { qos: 0 }, function(err) {
        if (err) {
          console.error('âŒ Failed to send MQTT message:', err);
        } else {
          console.log(`ğŸ“¤ Sent ${messageType} message via MQTT`);
        }
      });
    }

    // åˆ›å»º offer
    function createOffer(remotePeerId) {
      console.log("ğŸ¬ Creating offer for", remotePeerId);
      
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ¬ æ­£åœ¨åˆ›å»ºè¿æ¥é‚€è¯·...</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;
      
      peer_connection.createOffer().then(offer => {
        peer_connection.setLocalDescription(offer);
        sendSignalingMessage('offer', offer, remotePeerId);
        
        logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] ğŸ“¤ å·²å‘é€è¿æ¥é‚€è¯·</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }).catch(error => {
        console.error('âŒ Error creating offer:', error);
        logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ åˆ›å»ºè¿æ¥é‚€è¯·å¤±è´¥: ${error.message}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });
    }

    // å¤„ç† offer
    function handleOffer(offer, remotePeerId) {
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      logDiv.innerHTML += `<p style="color: #74c0fc;">[${timestamp}] ğŸ“ æ”¶åˆ°è¿æ¥é‚€è¯·ï¼Œæ­£åœ¨å“åº”...</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;
      
      peer_connection.setRemoteDescription(offer).then(() => {
        return peer_connection.createAnswer();
      }).then(answer => {
        peer_connection.setLocalDescription(answer);
        sendSignalingMessage('answer', answer, remotePeerId);
        
        logDiv.innerHTML += `<p style="color: #74c0fc;">[${timestamp}] ğŸ“¤ å·²å‘é€è¿æ¥å“åº”</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }).catch(error => {
        console.error('âŒ Error handling offer:', error);
        logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ å¤„ç†è¿æ¥é‚€è¯·å¤±è´¥: ${error.message}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });
    }

    // å¤„ç† answer
    function handleAnswer(answer) {
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      logDiv.innerHTML += `<p style="color: #51cf66;">[${timestamp}] âœ… æ”¶åˆ°è¿æ¥å“åº”ï¼Œæ­£åœ¨å»ºç«‹è¿æ¥...</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;
      
      peer_connection.setRemoteDescription(answer).catch(error => {
        console.error('âŒ Error handling answer:', error);
        logDiv.innerHTML += `<p style="color: #ff6b6b;">[${timestamp}] âŒ å¤„ç†è¿æ¥å“åº”å¤±è´¥: ${error.message}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      });
    }

    // å¤„ç† ICE candidate
    function handleIceCandidate(candidate) {
      peer_connection.addIceCandidate(candidate).catch(error => {
        console.error('âŒ Error adding ICE candidate:', error);
      });
    }

    // è·å–æœ¬åœ°åŠ å…¥æ—¶é—´
    let localJoinTime = Date.now();
    function getLocalJoinTime() {
      return localJoinTime;
    }

    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    document.addEventListener('DOMContentLoaded', function() {
      // TURN æœåŠ¡å™¨æµ‹è¯•æŒ‰é’®
      document.getElementById('testTurnBtn').addEventListener('click', testTurnServer);

      // ç½‘ç»œè¯Šæ–­æŒ‰é’®
      document.getElementById('diagnosisBtn').addEventListener('click', runNetworkDiagnosis);

      // ä¼˜å…ˆçº§è¿æ¥æµ‹è¯•æŒ‰é’®
      document.getElementById('priorityTestBtn').addEventListener('click', runPriorityConnectionTest);

      // åŠ¨æ€ç»‘å®š"åº”ç”¨æœ€ä¼˜é…ç½®"æŒ‰é’®ï¼ˆå› ä¸ºæ˜¯åŠ¨æ€ç”Ÿæˆçš„ï¼‰
      document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'applyOptimalMode') {
          applyOptimalConnectionMode();
        }
      });

      // å¼ºåˆ¶ TURN æ¨¡å¼æŒ‰é’®
      document.getElementById('forceRelayBtn').addEventListener('click', function() {
        forceRelay = !forceRelay;
        this.textContent = forceRelay ? 'ğŸ”„ å–æ¶ˆå¼ºåˆ¶ TURN' : 'ğŸš€ å¼ºåˆ¶ TURN æ¨¡å¼';
        this.className = forceRelay ? 'btn danger' : 'btn';
        
        const logDiv = document.getElementById('logs');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.innerHTML += `<p>[${timestamp}] æ¨¡å¼åˆ‡æ¢: ${forceRelay ? 'å¼ºåˆ¶ TURN æ¨¡å¼' : 'è‡ªåŠ¨æ¨¡å¼'}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
        
        // å¦‚æœå·²æœ‰è¿æ¥ï¼Œé‡æ–°åˆå§‹åŒ–
        if (peer_connection && currentStream) {
          stopConnectionMonitoring(); // åœæ­¢æ—§è¿æ¥çš„ç›‘æ§
          peer_connection.close();
          initializeWebRTC(currentStream);
        }
      });

      // æ‘„åƒå¤´æŒ‰é’®äº‹ä»¶
      document.getElementById('cameraBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getCameraStream);
        } else {
          getCameraStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // å±å¹•å…±äº«æŒ‰é’®äº‹ä»¶
      document.getElementById('screenBtn').addEventListener('click', function() {
        if (peer_connection) {
          replaceMediaStream(getScreenStream);
        } else {
          getScreenStream().then(stream => {
            initializeWebRTC(stream);
          }).catch(console.error);
        }
      });

      // é»˜è®¤ä½¿ç”¨æ‘„åƒå¤´
      getCameraStream().then(stream => {
        initializeWebRTC(stream);
      }).catch(console.error);
    });
  </script>
</html>
