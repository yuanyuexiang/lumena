<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lumena ç§»åŠ¨ç«¯</title>
    <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 10px;
      }

      .container {
        max-width: 100%;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 20px;
      }

      .header h1 {
        font-size: 24px;
        margin-bottom: 10px;
      }

      .section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .section h3 {
        color: #333;
        margin-bottom: 15px;
        font-size: 18px;
      }

      .input-group {
        margin-bottom: 15px;
      }

      .input-field {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .input-field:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 10px;
        transition: all 0.3s;
      }

      .btn.primary {
        background: #667eea;
        color: white;
      }

      .btn.success {
        background: #4CAF50;
        color: white;
      }

      .btn.danger {
        background: #f44336;
        color: white;
      }

      .btn.secondary {
        background: #6c757d;
        color: white;
      }

      .btn:active {
        transform: scale(0.98);
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid #eee;
      }

      .status-item:last-child {
        border-bottom: none;
      }

      .status-label {
        font-weight: bold;
        color: #333;
      }

      .status-value {
        color: #666;
        font-size: 14px;
      }

      .video-container {
        position: relative;
        width: 100%;
        height: 250px;
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 15px;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-placeholder {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        background: #f0f0f0;
        color: #666;
        text-align: center;
        flex-direction: column;
      }

      .connection-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 5px;
      }

      .connection-indicator.connected {
        background: #4CAF50;
      }

      .connection-indicator.disconnected {
        background: #f44336;
      }

      .connection-indicator.connecting {
        background: #ff9800;
      }

      .logs {
        max-height: 200px;
        overflow-y: auto;
        background: #f5f5f5;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        line-height: 1.4;
      }

      .button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .button-grid .btn {
        margin-bottom: 0;
      }

      /* å…¨å±è§†é¢‘æ¨¡å¼ */
      .video-fullscreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000;
        background: black;
      }

      .video-fullscreen video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .fullscreen-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }

      .fullscreen-controls .btn {
        width: auto;
        padding: 10px 20px;
        margin: 0;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ“± Lumena ç§»åŠ¨ç«¯</h1>
        <p>æ‰«ç æˆ–è¾“å…¥æˆ¿é—´å·åŠ å…¥è§†é¢‘é€šè¯</p>
      </div>
      
      <!-- æˆ¿é—´åŠ å…¥åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸšª åŠ å…¥æˆ¿é—´</h3>
        <div class="input-group">
          <input type="text" id="roomIdInput" placeholder="è¾“å…¥æˆ¿é—´å·" class="input-field">
          <button id="joinRoomBtn" class="btn primary">ğŸš€ åŠ å…¥æˆ¿é—´</button>
        </div>
        <div class="status-item">
          <span class="status-label">å½“å‰æˆ¿é—´:</span>
          <span class="status-value" id="currentRoom">æœªåŠ å…¥</span>
        </div>
        <div class="status-item">
          <span class="status-label">è¿æ¥çŠ¶æ€:</span>
          <span class="status-value" id="connectionStatus">æœªè¿æ¥</span>
        </div>
      </div>
      
      <!-- è§†é¢‘æ§åˆ¶åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸ“¹ è§†é¢‘æ§åˆ¶</h3>
        <div class="video-container" id="videoContainer">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="video-placeholder" id="videoPlaceholder">
            <p>ğŸ“·</p>
            <p>ç‚¹å‡»"å¼€å§‹è§†é¢‘"å¯åŠ¨æ‘„åƒå¤´</p>
          </div>
        </div>
        
        <div class="button-grid">
          <button id="startVideoBtn" class="btn success">ğŸ“· å¼€å§‹è§†é¢‘</button>
          <button id="stopVideoBtn" class="btn danger">â¹ï¸ åœæ­¢è§†é¢‘</button>
        </div>
        
        <button id="switchCameraBtn" class="btn secondary">ğŸ”„ åˆ‡æ¢æ‘„åƒå¤´</button>
        <button id="fullscreenBtn" class="btn secondary">ğŸ” å…¨å±é¢„è§ˆ</button>
      </div>

      <!-- è¿æ¥çŠ¶æ€ -->
      <div class="section">
        <h3>ğŸ“¡ è¿æ¥çŠ¶æ€</h3>
        <div class="status-item">
          <span class="status-label">è¿æ¥æ–¹å¼:</span>
          <span class="status-value">
            <span class="connection-indicator disconnected" id="connectionIndicator"></span>
            <span id="connectionType">æœªè¿æ¥</span>
          </span>
        </div>
        <div class="status-item">
          <span class="status-label">è§†é¢‘è´¨é‡:</span>
          <span class="status-value" id="videoQuality">-</span>
        </div>
        <div class="status-item">
          <span class="status-label">ç½‘ç»œå»¶è¿Ÿ:</span>
          <span class="status-value" id="networkDelay">-</span>
        </div>
      </div>

      <!-- æ—¥å¿—åŒºåŸŸ -->
      <div class="section">
        <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
        <div id="logs" class="logs"></div>
      </div>
    </div>

    <!-- å…¨å±è§†é¢‘æ¨¡å¼ -->
    <div id="fullscreenVideo" class="video-fullscreen hidden">
      <video id="fullscreenVideoElement" autoplay muted playsinline></video>
      <div class="fullscreen-controls">
        <button id="exitFullscreenBtn" class="btn danger">âŒ é€€å‡ºå…¨å±</button>
        <button id="fullscreenSwitchBtn" class="btn secondary">ğŸ”„ åˆ‡æ¢æ‘„åƒå¤´</button>
      </div>
    </div>
  </body>

  <script>
    let peer_connection;
    let mqttClient;
    let roomId = null;
    let localPeerId = 'user-' + Math.random().toString(36).substr(2, 9);
    let currentStream = null;
    let connectionStatsInterval;
    let currentFacingMode = 'user';
    let isFullscreen = false;

    // ä»URLè·å–æˆ¿é—´å·
    function getRoomFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('room');
    }

    // æ·»åŠ æ—¥å¿—
    function addLog(message, type = 'info') {
      const logDiv = document.getElementById('logs');
      const timestamp = new Date().toLocaleTimeString();
      const colors = {
        info: '#74c0fc',
        success: '#51cf66',
        error: '#ff6b6b',
        warning: '#ffd43b'
      };
      
      logDiv.innerHTML += `<p style="color: ${colors[type]};">[${timestamp}] ${message}</p>`;
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    // åˆå§‹åŒ– MQTT è¿æ¥
    function initializeMQTT() {
      const brokerUrl = 'wss://meteor.matrix-net.tech/mqtt';
      
      addLog('ğŸ”— æ­£åœ¨è¿æ¥MQTTæœåŠ¡å™¨...');
      
      mqttClient = mqtt.connect(brokerUrl, {
        clientId: localPeerId,
        clean: true,
        connectTimeout: 4000,
        username: 'matrix',
        password: 'sual116y',
        reconnectPeriod: 1000,
        protocolVersion: 4,
        keepalive: 60,
      });

      mqttClient.on('connect', function () {
        addLog('âœ… MQTTè¿æ¥æˆåŠŸ', 'success');
        document.getElementById('connectionStatus').textContent = 'MQTTå·²è¿æ¥';
        
        if (roomId) {
          mqttClient.subscribe(`webrtc/${roomId}/+/+`, function (err) {
            if (!err) {
              addLog(`ğŸ“¡ å·²è®¢é˜…æˆ¿é—´: ${roomId}`, 'success');
              
              mqttClient.publish(`webrtc/${roomId}/${localPeerId}/join-room`, JSON.stringify({
                type: 'join-room',
                userId: localPeerId,
                timestamp: Date.now()
              }));
              
              addLog(`ğŸšª å·²åŠ å…¥æˆ¿é—´: ${roomId}`, 'success');
            }
          });
        }
      });

      mqttClient.on('message', function (topic, message) {
        const topicParts = topic.split('/');
        const remotePeerId = topicParts[2];
        const messageType = topicParts[3];
        
        if (remotePeerId === localPeerId) return;
        
        try {
          const data = JSON.parse(message.toString());
          addLog(`ğŸ“¨ æ”¶åˆ°${messageType}æ¶ˆæ¯`);
          handleSignalingMessage(messageType, data, remotePeerId);
        } catch (error) {
          addLog('âŒ æ¶ˆæ¯è§£æå¤±è´¥', 'error');
        }
      });

      mqttClient.on('error', function (error) {
        addLog('âŒ MQTTè¿æ¥å¤±è´¥', 'error');
        document.getElementById('connectionStatus').textContent = 'MQTTè¿æ¥å¤±è´¥';
      });
    }

    // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
    function handleSignalingMessage(messageType, data, remotePeerId) {
      switch (messageType) {
        case 'room-ready':
          addLog(`âœ… æˆ¿é—´å‡†å¤‡å°±ç»ª`, 'success');
          if (currentStream && peer_connection) {
            setTimeout(() => createOffer(), 1000);
          }
          break;
          
        case 'answer':
          addLog(`âœ… æ”¶åˆ°è¿æ¥å“åº”`, 'success');
          handleAnswer(data);
          break;
          
        case 'candidate':
          handleIceCandidate(data);
          break;
      }
    }

    // è·å–æ‘„åƒå¤´æµ
    async function getCameraStream(facingMode = 'user') {
      try {
        const constraints = {
          video: {
            width: { ideal: 1280, max: 1920 },
            height: { ideal: 720, max: 1080 },
            facingMode: facingMode
          },
          audio: true
        };
        
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        return stream;
      } catch (error) {
        // é™çº§å°è¯•
        try {
          const fallbackStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: facingMode },
            audio: true
          });
          return fallbackStream;
        } catch (fallbackError) {
          throw new Error('æ— æ³•è·å–æ‘„åƒå¤´: ' + fallbackError.message);
        }
      }
    }

    // å¼€å§‹è§†é¢‘
    async function startVideo() {
      try {
        const stream = await getCameraStream(currentFacingMode);
        currentStream = stream;
        
        // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
        const videoElement = document.getElementById('localVideo');
        videoElement.srcObject = stream;
        videoElement.style.display = 'block';
        document.getElementById('videoPlaceholder').style.display = 'none';
        
        addLog('ğŸ“· æ‘„åƒå¤´å·²å¼€å¯', 'success');
        
        // åˆå§‹åŒ–WebRTCè¿æ¥
        initializeWebRTC(stream);
        
      } catch (error) {
        addLog('âŒ å¼€å¯è§†é¢‘å¤±è´¥: ' + error.message, 'error');
        alert('å¼€å¯è§†é¢‘å¤±è´¥: ' + error.message);
      }
    }

    // åœæ­¢è§†é¢‘
    function stopVideo() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
        
        const videoElement = document.getElementById('localVideo');
        videoElement.srcObject = null;
        videoElement.style.display = 'none';
        document.getElementById('videoPlaceholder').style.display = 'flex';
        
        if (peer_connection) {
          peer_connection.close();
          peer_connection = null;
        }
        
        addLog('â¹ï¸ æ‘„åƒå¤´å·²å…³é—­', 'warning');
      }
    }

    // åˆ‡æ¢æ‘„åƒå¤´
    async function switchCamera() {
      if (!currentStream) {
        alert('è¯·å…ˆå¼€å¯æ‘„åƒå¤´');
        return;
      }
      
      currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
      
      try {
        currentStream.getTracks().forEach(track => track.stop());
        
        const newStream = await getCameraStream(currentFacingMode);
        currentStream = newStream;
        
        // æ›´æ–°è§†é¢‘å…ƒç´ 
        const videoElements = [
          document.getElementById('localVideo'),
          document.getElementById('fullscreenVideoElement')
        ];
        
        videoElements.forEach(video => {
          if (video) video.srcObject = newStream;
        });
        
        // å¦‚æœæœ‰WebRTCè¿æ¥ï¼Œæ›¿æ¢è§†é¢‘è½¨é“
        if (peer_connection) {
          const videoTrack = newStream.getVideoTracks()[0];
          const sender = peer_connection.getSenders().find(s => 
            s.track && s.track.kind === 'video'
          );
          
          if (sender) {
            await sender.replaceTrack(videoTrack);
          }
        }
        
        addLog(`ğŸ”„ å·²åˆ‡æ¢åˆ°${currentFacingMode === 'user' ? 'å‰' : 'å'}æ‘„åƒå¤´`, 'success');
        
      } catch (error) {
        addLog('âŒ åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥: ' + error.message, 'error');
      }
    }

    // å…¨å±é¢„è§ˆ
    function toggleFullscreen() {
      const fullscreenDiv = document.getElementById('fullscreenVideo');
      const fullscreenVideo = document.getElementById('fullscreenVideoElement');
      
      if (!isFullscreen) {
        if (currentStream) {
          fullscreenVideo.srcObject = currentStream;
          fullscreenDiv.classList.remove('hidden');
          isFullscreen = true;
          
          // é”å®šå±å¹•æ–¹å‘ï¼ˆå¦‚æœæ”¯æŒï¼‰
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(() => {});
          }
        } else {
          alert('è¯·å…ˆå¼€å¯æ‘„åƒå¤´');
        }
      } else {
        fullscreenDiv.classList.add('hidden');
        isFullscreen = false;
        
        // è§£é”å±å¹•æ–¹å‘
        if (screen.orientation && screen.orientation.unlock) {
          screen.orientation.unlock();
        }
      }
    }

    // åˆå§‹åŒ–WebRTCè¿æ¥
    function initializeWebRTC(stream) {
      const iceServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:coturn.meteor.matrix-net.tech:3478' },
        {
          urls: 'turn:coturn.meteor.matrix-net.tech:3478?transport=tcp',
          username: 'matrix',
          credential: 'sual116y'
        }
      ];

      peer_connection = new RTCPeerConnection({ iceServers });

      stream.getTracks().forEach(track => {
        peer_connection.addTrack(track, stream);
      });

      peer_connection.onicecandidate = e => {
        if (e.candidate) {
          sendSignalingMessage('candidate', e.candidate);
        }
      };

      peer_connection.onconnectionstatechange = () => {
        const state = peer_connection.connectionState;
        const indicator = document.getElementById('connectionIndicator');
        
        switch (state) {
          case 'connected':
            addLog('ğŸ‰ P2Pè¿æ¥å·²å»ºç«‹ï¼', 'success');
            document.getElementById('connectionType').textContent = 'å·²è¿æ¥';
            indicator.className = 'connection-indicator connected';
            startConnectionMonitoring();
            break;
          case 'disconnected':
            addLog('ğŸ”Œ P2Pè¿æ¥å·²æ–­å¼€', 'warning');
            document.getElementById('connectionType').textContent = 'å·²æ–­å¼€';
            indicator.className = 'connection-indicator disconnected';
            break;
          case 'failed':
            addLog('âŒ P2Pè¿æ¥å¤±è´¥', 'error');
            document.getElementById('connectionType').textContent = 'è¿æ¥å¤±è´¥';
            indicator.className = 'connection-indicator disconnected';
            break;
        }
      };

      setTimeout(() => createOffer(), 1000);
    }

    // åˆ›å»º offer
    function createOffer() {
      if (!peer_connection) return;
      
      addLog('ğŸ¬ æ­£åœ¨åˆ›å»ºè¿æ¥è¯·æ±‚...');
      
      peer_connection.createOffer().then(offer => {
        return peer_connection.setLocalDescription(offer);
      }).then(() => {
        sendSignalingMessage('offer', peer_connection.localDescription);
        addLog('ğŸ“¤ å·²å‘é€è¿æ¥è¯·æ±‚', 'success');
      }).catch(error => {
        addLog('âŒ åˆ›å»ºè¿æ¥è¯·æ±‚å¤±è´¥: ' + error.message, 'error');
      });
    }

    // å‘é€ä¿¡ä»¤æ¶ˆæ¯
    function sendSignalingMessage(messageType, data) {
      if (!mqttClient || !roomId) return;
      
      const topic = `webrtc/${roomId}/${localPeerId}/${messageType}`;
      mqttClient.publish(topic, JSON.stringify(data));
    }

    // å¤„ç† answer
    function handleAnswer(answer) {
      if (peer_connection) {
        peer_connection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    }

    // å¤„ç† ICE candidate
    function handleIceCandidate(candidate) {
      if (peer_connection) {
        peer_connection.addIceCandidate(new RTCIceCandidate(candidate));
      }
    }

    // å¼€å§‹è¿æ¥ç›‘æ§
    function startConnectionMonitoring() {
      if (connectionStatsInterval) {
        clearInterval(connectionStatsInterval);
      }
      
      connectionStatsInterval = setInterval(async () => {
        try {
          const stats = await peer_connection.getStats();
          stats.forEach(report => {
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              if (report.currentRoundTripTime) {
                const rtt = Math.round(report.currentRoundTripTime * 1000);
                document.getElementById('networkDelay').textContent = `${rtt} ms`;
              }
            }
            
            if (report.type === 'outbound-rtp' && report.mediaType === 'video') {
              const bitrate = Math.round(report.bytesSent * 8 / report.timestamp * 1000);
              document.getElementById('videoQuality').textContent = `${bitrate} kbps`;
            }
          });
        } catch (error) {
          console.error('è·å–è¿æ¥ç»Ÿè®¡å¤±è´¥:', error);
        }
      }, 2000);
    }

    // åŠ å…¥æˆ¿é—´
    function joinRoom() {
      const inputRoomId = document.getElementById('roomIdInput').value.trim();
      if (!inputRoomId) {
        alert('è¯·è¾“å…¥æˆ¿é—´å·ï¼');
        return;
      }
      
      roomId = inputRoomId;
      document.getElementById('currentRoom').textContent = roomId;
      
      initializeMQTT();
      addLog(`ğŸšª æ­£åœ¨åŠ å…¥æˆ¿é—´: ${roomId}`);
    }

    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    document.addEventListener('DOMContentLoaded', function() {
      // ä»URLè·å–æˆ¿é—´å·
      const urlRoomId = getRoomFromUrl();
      if (urlRoomId) {
        roomId = urlRoomId;
        document.getElementById('roomIdInput').value = roomId;
        document.getElementById('currentRoom').textContent = roomId;
        initializeMQTT();
      }
      
      // äº‹ä»¶ç›‘å¬å™¨
      document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
      document.getElementById('startVideoBtn').addEventListener('click', startVideo);
      document.getElementById('stopVideoBtn').addEventListener('click', stopVideo);
      document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
      document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
      document.getElementById('exitFullscreenBtn').addEventListener('click', toggleFullscreen);
      document.getElementById('fullscreenSwitchBtn').addEventListener('click', switchCamera);
      
      // å›è½¦é”®åŠ å…¥æˆ¿é—´
      document.getElementById('roomIdInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          joinRoom();
        }
      });
      
      // é˜»æ­¢é¡µé¢ç¼©æ”¾
      document.addEventListener('touchmove', function(e) {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // åˆå§‹éšè—æœ¬åœ°è§†é¢‘
      document.getElementById('localVideo').style.display = 'none';
      
      addLog('ğŸ“± ç§»åŠ¨ç«¯å·²åŠ è½½å®Œæˆ', 'success');
    });
  </script>
</html>